Although JSON Web Tokens (JWTs)~\cite{RFC7519} are not inherently encrypted,
they still serve an essential purpose for some forms of secure data transfer.
By combining JWTs with JSON Web Encryption (JWE)~\cite{rfc7516}, secure
intercommunication between two or more parties can be achieved.

\subsubsection{JSON Web Token (RFC 7519)}
JWTs were introduced as part of RFC 7519 in 2015~\cite{RFC7519}.
It is a compact, URL-safe string intended to transfer data between two entities.
They can be used as part of an authentication and authorization scheme in a web
service, application, or API\@.
The data in the string is intended as a payload and is referred to as a
\texttt{claim}~\cite{RFC7519}.

A JWT typically consist of three parts: header, payload, and signature.
The header and payload are serialized into JavaScript Object Notation (JSON)
and then encoded using a Base64Url encoding to ensure a URL-safe
format~\cite{RFC7519}.

The token contains an expiry timestamp, which, when decoded, is validated if
the timestamp is not passed at the time of decoding.
JWTs can be cryptographically signed using various algorithms like Hash-Based
Message Authentication (HMAC), Rivest-Shamir-Adleman (RSA), or
Elliptic-Curve Digital Signature Algorithm (ECDSA) ensuring the integrity and
authenticity of the token~\cite{RFC7519}.
This prevents unknown authorities from constructing or hijacking existing
tokens.\footnote{
  Hijacking a token could happen by a man-in-the-middle attack.
  This is done by a third-party individual listening and intercepting traffic
  in order to either read data or input their own in a client's request.
  This would allow an attacker to gain access to privileged information.
}

The URL-safe format of a JWT is often performed through a Base64 encoding, which
permits larger bits of data to be sent in a compressed, safe\footnote{
  Safe in this context should not be interchanged with secure.
  We reference safe as a way to transfer the data over the selected protocol,
  in most cases HTTP(S).
} format~\cite{RFC7519}.
JWTs are widely used for scenarios such as single sign-on (SSO), user
authentication, and securing API endpoints by providing an efficient and
stateless mechanism for transmitting information about the user's identity,
permissions, and other relevant data~\cite{karande2018securingnode}.

The process functions as follows:
\begin{enumerate}
  \item The client completed an authentication request.
  \item A token was constructed and created through a claim on the server.
  The claim could have been any data the server wished to use to authenticate
  the legitimacy of a future request.
  \item The claim was signed with the desired algorithm.
  This could also have been a secret, stored on the server.
  \item As part of the response to a request, the server appended the
  token.\footnote{
    A common place to embed these tokens is in the Authorization part of the
    HTTP header~\cite{RFC7519}.
  }
  \item The client received the token and carried it upon the next performed
  request.
  \item When the server received the token again,
  it validated the \texttt{exp} property of the JSON object and took action
  accordingly.
\end{enumerate}

\subsubsection{JSON Web Encryption (RFC 7516)}
Complimenting the JWT standard are JWEs (RFC 7516).
Introduced around the same time as JWTs, in May 2015, there are many parallels
between the two, but the significant distinction between them is that JWEs are
encrypted~\cite{rfc7516}.
This encryption can happen through AES (see Section~\ref{subsec:aes}) and
provides integrity and authenticity for the token.
This prevents eavesdropping or tampering with the token during transit.
Combined with JWT, JWE enhance the overall security of JWT-based implementations,
making them more suitable for transferring sensitive data between
intercommunicating entities on the Web.
% This section might be split up into two parts, dividing JWT and JWE