
Due to the nature of a password manager, where a user should not know their
passwords in order to keep them secure, LessPM can't follow a typical
authentication scheme.

In a typical authentication scheme, a password can be stored and hashed using
multiple vectors to increase security.
Such measures include using a \texttt{salt}\footnote{
  Salting is the process of adding a randomly generated string consisting of
  arbitrary characters to the password before creating a hash~\cite{Kharod2015}.
  This randomness of the salt makes identical passwords hash to different
  values, which can then be stored in the database.
} and \texttt{pepper}\footnote{
  A pepper is the process of adding a hardcoded string to the password.
  Unlike the salt, the pepper is often stored in the code and used as an
  extra measure to increase security.
  A sufficently large pepper will require a malefactor to spend extra time to
  compute a hash.
}.
When trying to authenticate, the user would provide their UID and password.
These values are collected from the database, where a password can be stored in
any form from plaintext to a hashed variation through a hashing algorithm
such as PBKDF2, Argon2, or the SHA-family.
After the values are collected from the database, the authentication scheme
checks them against the provided values from the user.

If a \texttt{salt} and \texttt{pepper} is part of the authentication scheme,
they are both required to be appended (in the correct order) to the
user-provided password, before the hashing and validation can take place.
Upon successful validation, the user is considered authenticated and logged in.

Securing the user passwords in LessPM made this process more complicated than
the one described above.
Furthermore, since the passwords in a general password manager should be a
randomly generated string unknown to the applicant, we cannot hash the
user-provided input and compare that hashed value.
This influenced the decision to introduce encryption on the passwords in
LessPM\@.

\subsubsection{Advanced Encryption Standard}
We decided on the Advanced Encryption Standard (AES) with a 256-bit key-size
(AES-256).
AES has, since its inception in 1998, become the gold standard for encrypting
various information across
applications~\cite{schneier2015applied,rijndael_book}.
In 2001, it was adopted as the successor of the leading Data Encryption
standard (DES) by The National Institute of Standards and Technology (NIST)
in 2001~\cite{nist_aes_winner}.

AES operates on fixed-sized units of data referred to as
\texttt{blocks}~\cite{nistfips197blocks}, supporting keys of sizes 128-, 192-
and 256-bit~\cite{nistfips197intro}.
A Substitution-Permutation Network (SPN) structure forms the basis of the
design, which achieves a high level of encryption and security in LessPM
through multiple rounds of processing by combining substitution and
permutation~\cite{nistfips197specification}.
AES-256 employs a 256-bit key and consist of 14 rounds of encryption, offering
an advanced level of security compared to its counterparts with shorter key
lengths and fewer rounds~\cite{nistfips197256}.

In each round of encryption, AES-256 undergoes four primary transformations,
operating on a $4\times4$ block, as described below:
\newpage

  \begin{enumerate}
    \item \textbf{SubBytes} is a non-linear substitution step where each byte is
    replaced with another according to a predefined lookup table.
    \item \textbf{ShiftRows} cyclically shifts each row of the state over a
    certain number of steps.
    of the State over varying numbers of bytes while preserving their original
    values.
    \item \textbf{MixColumns} is a process that works on the columns of the
    state by combining the four bytes in each column through a mixing operation.
    \item \textbf{AddRoundedKey} involves combining a subkey with the state\footnote{
      The term \texttt{state} refers to an intermediate result that changes as
      the algorithm progress through its phases.
    }
    ~by applying a bitwise XOR operation.
  \end{enumerate}

The larger key-size in AES-256 provides an exponential increase in the number
of possible keys for each password encrypted in LessPM, making it
significantly more resilient to brute-force attacks and further solidifying
its position as a robust encryption standard for safe-guarding sensitive
information.\footnote{
  The practical number of potential keys for an AES-256 implementation is
  $2^{256}$ possibilities. This gives us an approximation of
  $1.1579209 \times 10^{77}$ options.
  The number is theoretical, as this is a worst-case scenario of options an
  attacker must go through to find the right key.
}

\subsubsection{AES-256 in LessPM}
AES-256 requires a 256-bit key to encrypt and decrypt data.
Since the CID generated by WebAuthn is unique and random for each application
and device, we decided to have the CID serve as a basis for constructing the
key used to encrypt passwords in LessPM\@.

We based the key for each password on the following premise:
\begin{enumerate}
  \item
  We took advantage of the fact that each CID is unique in every application
  (see Section~\ref{subsec:webauthn-methodology}).
  We therefore used 192-bits of the string that is the CID\@, converting it to
  integers.
  Since every CID is unique depending on the device, some CIDs are smaller
  than 192-bit and some are longer.
  To compensate for this, LessPM constructed and generated a random padding
  to reach the remaining difference when the CID is smaller than 192-bit.
  \item
  We appended each key with a random 128-bit salt of integers and stored these
  bits with the entry in the database.
  \item
  Then we add a 128-bit of pepper collected from an environment variable to
  in LessPM's code to finish the key.
\end{enumerate}
We used these 448 bits as the input for the key-derivation function,
Argon2 (See Section~\ref{subsec:hashing}).

Upon hashing, each key is also subject to a 128-bit salt explicitly generated
for the password's key in LessPM\@.
After encryption, the password is stored in an encrypted Base64-encoded
format in LessPM if the authentication process proved successful.
This process happened individually for all passwords constructed and stored
within LessPM\@.

