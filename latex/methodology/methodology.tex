
Exploring the development and implementation of LessPM, our focus will be on the
key components, technologies, and steps that form the system's development
process.
A crucial part of the development and system was its security and robustness.

Our approach encompasses an explanation of the system architecture, the
technologies and tools utilized and the development process to create the
prototype.
By providing a comprehensive account of the system development process, we aim
to enable readers to understand the technical aspects of our work as well
as to assess the validity and relevance of our findings.

\subsection{Environment}\label{subsec:environment}
To implement the system, we approached the development from a type-safety
environment.

\subsubsection{Server}
We chose Rust as the programming language for our backend, which provided
significant benefits regarding the software development environment.

Rust's emphasis on safety and performance allowed us to create a highly
secure and efficient environment for our implementation without the risks
typically associated with memory-related
vulnerabilities~\cite{rivera2019preserving}.
The built-in memory management and focus on concurrency ensures that the
software runs smoothly, which is crucial~\cite{fischer1985impossibility} when
dealing with sensitive user data.

Additionally, Rust's surrounding ecosystem is at rapid
growth~\cite{librs-stats}, containing a vast library of high-quality
crates\footnote{
  \texttt{Crate} is the Rust-specific name for a package or library.
}, which enables expeditious development and easy integration of various
functionality.
Utilizing Rust's distinctive features, the LessPM achieves enhanced security and
reliability in the context of user authentication~\cite{rivera2019preserving},
showcasing the benefits of utilizing a modern programming language.

LessPM ran an instance of an HTTPS server, serving as a wrapper for the
sensitive data.\footnote{
  We took advantage of the Authorization header during development, as specified
  in RFC 7519.
  However, the framework we used for the server required us to expose the usage
  of \texttt{Authorization header} to access it in the client.
  See Section~\ref{subsec:security-analysis} for further explanation.
}
The Chromium developers mandate this constraint to guarantee that the pertinent
API is invoked exclusively within a secure context~\cite{webdev2021credential}.
During development, we established a secure connection by using a self-signed
certificate for the \texttt{``localhost''} domain.
As a deliberate decision, we opted for MongoDB due to its NoSQL architecture,
which facilitated the storage of Object-like structures~\cite{mongodb2021nosql}
including passwords, user accounts, and other related data that LessPM stores.

\subsubsection{Client}
An essential part of the implementation was to create a viable client that could
function as a visual entry point to LessPM and proof-of-concept.
For the simplicity of the project, we chose React as a framework.
React is a JavaScript library for building user interfaces, offering an
efficient and flexible approach to web development.
The design of LessPM was influenced by the principles of
least-knowledge~\cite{lieberherr1990assuring}.
This influenced the decision to ensure that the client only retained
necessary information to function properly, containing no knowledge of
the server nor its implementation.

In a system that contains authentication and authorization in a stateless
protocol such as HTTPS, some information is needed to authorize a client
between requested resources.
LessPM took advantage of JWT/JWE (
Section~\ref{subsec:json-web-tokens}
) for this purpose.
\todo[inline]{
  Put in some information about JWT and JWE.
}
We strongly encrypted the Base64-encoded data passed between the server and
client using AES-256 (Section~\ref{subsec:aes}).

We took advantage of React's ability to construct a single-page application with
no routing capabilities, avoiding the possibility of utilizing any URL tampering
or manipulation\footnote{
  Malefactors can perform URL Manipulation, which involves modifying a URL to
  request resources that would otherwise be inaccessible to a user.
} to attempt privilege escalation or
accessing restricted data.

Further, the server checked and verified the token before proceeding with any
requests made to it.
This information is updated and inspected between each
re-render~\cite{react-component} of the client.

When initiating the project's development, we had a strong vision of creating
a client that could seamlessly integrate with Chromium-based browsers as
an extension.\footnote{
    In the client's project folder are traces of a manifest.json file and build
    scripts to have the client run in an extension.
}
However, we quickly discovered that the Rust cargo used to perform WebAuthn
requests did not implement this support.
We reported this issue
\href{https://github.com/kanidm/webauthn-rs/issues/288}{upstream to the authors}
of the cargo, and we will continue to work with the authors to ensure a proper
implementation of this functionality in the future.

\subsection{WebAuthn}\label{subsec:webauthn-methodology}
We used WebAuthn to perform passwordless authentication in LessPM.
WebAuthn is a collaborative open standard between the FIDO Alliance and W3C\@.
The aim of the standard is to implement a secure, robust key-based
authentication system for the web, to strongly authenticate users through
biometrics~\cite{webauthn_level_2}.
The concept relies on the use of a third-party device, called an
Authenticator Device (AD), which leverages asymmetric cryptography.
These devices employ biometric or hardware-based mechanism to provide secure
and reliable means of authenticating a user in LessPM\@.

Upon registering in LessPM, the AD generates a key-pair called a Passkey.
This key contains a CID uniquely generated for each registered
key-pair~\cite{webauthn_credential_id,webauthn_public_key_credential}, per
services registered on the AD\@.

Further, if a malefactor gains access to an individual's Passkey, they might
compromise one specific service, whereas a traditional password could
potentially compromise multiple services where password reuse
occurs~\cite{wang2018next}.
This suggests that WebAuthn could create a stronger level of security, whereas
a traditional password exposed in a leak might leave a user susceptible to
losing access across services and devices through the reused password.

WebAuthn attempts to mitigate phishing, man-in-the-middle, and brute-force
attacks through its intuitive design~\cite{webauthn_level_2}.
By leveraging the increasing market of smartphones with
biometrics~\cite{statista-biometric-transactions}, WebAuthn becomes a natural
extension in terms of authentication.

\subsubsection{Registration}\label{subsubsec:metho-registration}
When a user tried registering in LessPM, the client performs a request to the
server, called a Relying Party (RP), carrying a relevant User Identifier
(UID. i.e.\ username, phone number, email, Etc.).
This is done to check whether a user with a similar UID existed\footnote{
  WebAuthn does not require to check whether the CID generated by the AD exists.
  However, accepting users with similar identifier might leave a risk of
  providing unauthorized access.
  Hence why LessPM performs such a check.
} in the system, and LessPM denies the registration process if it existed.

If there are no users with a similar UID, LessPM responds by initiating a
Registration Ceremony (RC) and generate a challenge and a Unique User
Identifier (UUID) version 4.

which is sent to the client~\cite{webauthn-2}.

Using this challenge, LessPM's client called the browser-integrated WebAuthn
Application Programming Interface (API), prompting the user to utilize their
AD to create a new Passkey credential through the Client To Authenticator
Protocol (CTAP2)\footnote{
  The user is prompted to use their AD to prove their presence, which can
  involve facial recognition, providing a fingerprint, or any other modality
  supported by the device that the user chooses.
} for LessPM\@.

Finally, the AD signs the challenge using the private key stored on the
device.
The created public key, signed challenge, and additional metadata
into are combined into a public key credential object, which is forwarded
to the client through CTAP2 and then sent to LessPM\@.

LessPM then verifies the authenticity of the signed challenge and public key
through WebAuthn, before storing the key with the generated UUID and the
username provided.
Thus completing the RC\@.
\todo[inline]{
  This process can be sign in figure huhu.
}


We generated a JWE during this process, which was signed with RSASSA-PSS using
SHA-512 before getting encrypted with AES-256
(See Section~\ref{sec:futurework}).
This claim is then attached to the request's \texttt{Authorization} header,
along with the Creation options from WebAuthn
(See Section~\ref{subsec:webauthn}).

The \texttt{expiration} time for this claim is set to one minute to allow the
user some time to authenticate.\footnote{
  WebAuthn describes a timeout performed within the system. In our case, this
  timeout is one minute.
  However, we chose to add this extra step to secure the project further, and JWEs require an expiry time. See Section~\ref{subsec:json-web-tokens}.
}
The claim expired after this minute, and the user would then have to restart the
process.
This expiration timer was a decision we made to emphasize security within LessPM
further.

When the response returned to the user, LessPM used the browser's built-in
WebAuthn API to prompt the user for their authentication
(See Section~\ref{subsec:webauthn}).
At this point, it is entirely up to the user to decide what device to use to
authenticate.
We used an Apple iPhone 13 Pro Max, a Samsung S21, and a Samsung Galaxy A52 to
test authentication.\footnote{
  Other alternatives included a YubiKey, NitroKey, Etc.
}

We scanned the QR codes prompted through our phones, which initiated the
key-pair generation on the device after a successful facial recognition.
\footnote{
  There is a question of concern that photography can bypass facial recognition.
  Apple uses built-in sensors to scan depth, colours and a dot projector to
  create a 3D scan of a person's face.
  However, this approach prevents the use of photography to authenticate through
  their FaceID and TrueDepth technology~\cite{apple-support}.
}
The public key then gets transmitted to the browser and sent to the Relying
Party through a new request.

Before the request reaches the Relying Party, an authentication middleware
checks for the JWE sent earlier and denies the request with an
\texttt{Unauthorized} HTTP status code if the request is invalid.
\footnote{
  Validity in this context means not timed out, tampered with, or similar.
}
If WebAuthn can validate the key and metadata sent with the request, the user
gets stored in the database, along with the UUID generated.

\subsubsection{Authentication}\label{subsubsec:metho-authentication}
Authentication worked similarly to the registration process.
Upon receiving an incoming request, the server checked the database.
The server immediately rejected the request if the user did not exist in the
database.

Further, the server attempted an Authentication Ceremony by collecting the
public key from the database.
Upon validation\footnote{
  Validation in this context only means that the key stored in the database is
  valid.
} of the public key, the server creates a new JWE, which also receives an
\texttt{expiry} of one minute for the user to authenticate (See
Section~\ref{subsec:webauthn}), before sending that and the challenge in the
response.
We then prompt the user to authenticate with their original authenticator
that they used in the registration step, having the authenticator sign the
challenge before performing a new request to the server with the signed
challenge.
The server considered the user authenticated if the Relying Party accepted the
signed challenge.

Finally, the user had a 15-minute timeframe to perform the necessary activity
within LessPM\@.
The specification for JWT does not specify upper- or lower bounds for this
value ~\cite{RFC7519}.

\subsubsection{Password Creation \& Retrieval}\label{subsubsec:creation-and-retrieval}
Passwords are sensitive in nature, so it seems only natural in a security
context to enforce an extra level of authentication upon retrieving and creating
one unique password.\footnote{
  We retrieved a complete list of the user's passwords upon successful authentication.
  The hashed version of the password is stripped of the returned values to protect and enforce security.
}

A user is presented with the following options when they initiate a password
creation:

\begin{itemize}
  \item \textbf{User Identifier}: An identification that the user wants to
  associate with the password entry they are storing.
  Such as a username, phone number, or email.
  \item \textbf{Website}: A URL or similar where the password belongs.
  \item \textbf{Password}: The user is prompted with the input to create a
  strong password automatically, choosing options such as numbers, special
  symbols, smaller or larger characters, and the length.
  As an option, the user was also permitted to construct their password but
  warned by a warning saying that this option is less secure.
\end{itemize}

As a final step before a password is created and stored, the user is prompted to
reauthenticate with their AD\@.
The password is created and stored in the database if this authentication
process is successful.

Users needed to make a new authentication request when they wanted to retrieve
the plaintext version of the password.
This step is done in part to validate the user's presence\footnote{
  This approach is also used in password managers on phones to avoid situations
  where a user might have left their computer unlocked.
} but also to gather the necessary bits for the key-reconstruction
(See Section~\ref{subsec:password-encryption}).

\subsection{Cors}\label{subsec:cors}
Cross-Origin Resource Sharing (CORS) must be configured correctly when the
server and client are running separately on different ports.

When a web page tries to access a resource hosted on another domain, browsers
perform an additional request to the server, called a \texttt{``preflight''}.
The preflight request determines whether the
request that the web page is trying to make to the server is allowed.
This request is done through the \texttt{OPTIONS} method in HTTP and contains
some information about the origin, accepted Content-Type, and similar for the
actual request.

The server responds to this with what methods and headers are allowed, denying
the actual request from ever happening if the preflight is not successful.

We constructed a CORS \texttt{layer}\footnote{
  In this context, we referred to a layer as a wrapper around all other
  requests.
} which contained the two domains for the server and client, permitted
credentials\footnote{
  To pass the JWT token back and forth between the server
} and then permitted the two HTTP methods \texttt{POST} and \texttt{GET}.
We also ensured the \texttt{Content-Type, Authorization}, and \texttt{Cookie}
headers are permitted.

Any other methods or headers should abort the request in the preflight.

\subsection{Cookie}\label{subsec:cookie}
JavaScript can access and manipulate \texttt{Cookies}~\cite{he2019malicious}.
We utilized the browser's local cookie storage to attempt secure authentication
between requests.\footnote{
  The cookie storage in a browser is subject to any vulnerabilities that can be
  performed on an SQLite database while having access to the computer where it
  is running.
}
We attempted a couple of strategies listed below to fortify the cookie that
LessPM set in the browser against a malefactor:
\begin{itemize}
  \item \textbf{Strict SameSite}:
  This ensures that the cookie is safeguarded against Cross-Site Request Forgery
  (CSRF) attacks and remains restricted to its original origin domain.
  \item \textbf{Expires}:
  Once the system authenticated the user, it gave the cookie a Time-to-Live
  (TTL) mechanism similar to the JWE, which remained valid for only 15 minutes.
  \item \textbf{Secure}:
  We applied the \texttt{Secure} attribute to ensure that the cookie was only
  accessible through the HTTPS protocol.
  This protocol encrypts the data being sent back and forth between the client
  and the server, attempting to avoid eavesdroppers.
  \item \textbf{HttpOnly}:
  Setting HttpOnly tells the browser to make this cookie inaccessible through
  JavaScript.
  This property is important to mitigate session hijacking.
\end{itemize}

\subsection{Password Encryption}\label{subsec:password-encryption}
A password can be stored and hashed using a \texttt{salt} in a typical
authentication scheme.
When trying to authenticate, the user would provide their UID and password.
These values are collected from the database and checked with the random
salt\footnote{
  Salting is the process of adding a randomly generated string consisting of
  arbitrary characters to the password before creating a hash~\cite{Kharod2015}.
} that was generated when the user registered.

Securing the applicant's passwords made the process more complicated than the
one described above.
Furthermore, since the passwords in a password manager should be a randomly
generated string unknown to the applicant, we cannot hash it and compare the
input from the user.

We decided on the AES-256 (see Section~\ref{subsec:aes}), as a high form of
encryption is paramount to securing the passwords.
AES requires a 256-bit key to encrypt and decrypt the data.
Since the CID generated by WebAuthn is unique and random for each application
and device, this serves as a basis for constructing the key.

We based the key for each password on the following premise:
\begin{enumerate}
  \item
  We take advantage of the fact that each CID is unique in every application
  (see Section~\ref{subsec:webauthn}).
  We therefore used 192-bits of the string that is the CID\@, converting it to
  integers.
  Since every CID is unique depending on the device, we generated padding to
  reach the remaining difference when the CID does not contain 192-bit.
  \item
  We appended each key with a random 128-bit salt of integers and stored these
  bits with the entry in the database.
  \item
  Then we add a 128-bit of pepper collected from the environment variable to
  finish it.
\end{enumerate}
We used this 448-bit as the input for the key-derivation function,
Argon2 (See Section~\ref{subsec:hashing-through-argon2}).
Upon hashing, each key is also subject to a 128-bit salt explicitly generated
for the key.

\subsection{Hashing}\label{subsec:hashing}
\todo[inline]{
When we searched for a good key-derivation function, we first came across
  Password-Based Key Derivation Function 2 (PBKDF2).
We saw PBKDF2 as a good solution for the project, but after researching the
topic further, we ended up with Argon2.

Argon2 is regarded by some to be more secure than PBKDF2 due to its modern
design considerations, including protection against side-channel attacks and
memory-hardness, which make it more resistant to brute-forced and rainbow
table attacks.
Argon2 also offers customization of parameters for flexibility in adapting to
changing hardware technologies and security requirements.
PBKDF2 offers to set an amount of iterations to construct the hash and which
pseudorandom function to use.
}

Since LessPM is required to run in as safe of an environment as possible,
Argon2's configuration option is an excellent solution.

\subsubsection{Configuring Argon2}
Argon2's hashing output is dependable on
configurations~\cite{argon2specs}.\footnote{
  Dependable in this context refers to each configuration that can
  possibly be constructed.
  An instance of Argon2 with 256 Megabytes of \texttt{memory} will not return
  the same hash as 255 Megabytes.
  The same is true for the amount of \texttt{iterations} and
  \texttt{parallelism}.
}
Given that we emphasized security, we opted for the \texttt{Argon2id}
configuration, which gave us equal protection against side-channel and
brute-force attacks.

\todo[inline]{
  A part of Argon2's customizability is the offer to set the option for a
  required amount of memory to do the hashing.
}
These options would force a malefactor to use a specific amount of memory for
each attempt to construct the hash.
The only way a malefactor can get passed this requirement is to purchase more
memory.\footnote{
  As a side note, the increase in memory usage will scale as technology evolves
  and more memory becomes common.
}

For LessPM, we used 128 Megabytes of memory to construct the hash.\footnote{
  According to~\cite{argon2specs}, the reference implementation using Argon2d
  with 4Gb of memory and 8-degree parallelism, the hashing process should take
  0.5 seconds on a CPU with 2Gz. However, we were unsuccessful in seeing
  anywhere close to similar results.
}
We went for the default suggestion of two iterations to complement the memory.
To finalize the configuration, we added 8 degrees of parallelism since the
system where we developed it consists of 8 cores.~\footnote{
  The degree of parallelism is affected by how many cores a CPU
  contains~\cite{argon2specs}.
}

\subsection{JWT \& JWE}\label{subsec:jwt}
The JWT contained data we could use to validate an authenticated user between
HTTP requests, which we encoded as a URL-safe base64 string
(See Section~\ref{subsec:json-web-tokens}).
According to~\cite{RFC7519}, these should be attached to the authorization part
of a request, along with a \texttt{Bearer} part.
These tokens are cryptographically signed with RSASSA-PSS using SHA-512 with a
key-pair stored on the server to avoid forgery.

For each step in registration~\ref{subsubsec:metho-registration},
authentication~\ref{subsubsec:metho-authentication}, and
password creation/retrieval~\ref{subsubsec:creation-and-retrieval}, different
tokens with different information are constructed, verified, and
discarded.\footnote{
  The token for password creation/retrieval is the same as verifying that a user
  is signed in and authorized to create entries on behalf of the user.
}
We opted for this approach so that an exposed token could not serve as more than
one entry point for one of the steps.

By default, these tokens are not encrypted.
It is out of the question to unnecessarily expose any sensitive details about
the server's inner workings.
Therefore, we decided to incorporate a part inspired by JWE.\footnote{
  To properly implement JWE, metadata should be encoded into the token, such as
  what algorithm performs the encryption~\cite{rfc7516}. For further
  explanation, see Section~\ref{sec:futurework}.
}
Before any token is attached to a response from the server, the token is
encrypted using AES-256\@.
The Base64 gets encrypted into a ciphertext and then turned into a new Base64
encoding.
An example of this can be seen in Appendix~\ref{subsec:base64-and-ciphertext}.

We decoded the Base64, decrypted the ciphertext, and decoded the JWT-Base64 to
reconstruct the claim when the server received a new request.
We used this claim to gather details about the user who made the request and
responded accurately to the request accordingly.

\todo[inline]{The following section}

\subsection{Security Analysis}\label{subsec:security-analysis}
The security of a passwordless password manager is of paramount importance to
protect sensitive user infromation and prevent unauthorized access.
In this subsection, we conduct a comprehensive security analysis, identifying
  potential attack vectors and outlining the defensive measures that have
  been implemented to mitigate tehse risks.

The defensive measures include industry-standard security protocols such as
  HTTPS, JWT/JWE, Argon2 hashing, salt and pepper techniques, CORS
  configuration, and secure cookie management.
Additionally, different JWTs are used for registration, authentication, and
  password creation/retrieval to minimize the risk of exposure.
These defensive measures collectively aim to provide a robust and secure
  architecture for LessPM, safeguarding against various threats and ensuring
  the confidentiality, integrity, and availability of user data.
\begin{enumerate}[label=$\blacktriangleright$]
  \item \textbf{HTTP}

  \textbf{Weakness:}
  Any server running HTTP (Hypertext Transfer Protocol) is passing data
  between a server and a connecting client.
  With HTTP, this data is unencrypted.
  A malefactor can eavesdrop this data, performing a man-in-the-middle attack,
  replacing information, reading tokens, perform header inections, Etc. with 
  this unencrypted traffic.

  \textbf{Defensive Mechanism:}
  Upgrading the HTTP connection to HTTPS ensures that communication between the
  client and server is encrypted through Transport Layer Security (TLS).
  It provides confidentiality and integrity of data transmitted over the
  network, making it more difficult for attackers to intercept or tamper with
  sensitive information.

  \item \textbf{JSON Web Tokens (JWT)}

  \textbf{Weakness:}
  JWTs are signed with a secret specific to the server.
  However, if this secret is discovered or leaked, a malefactor could use this
  information to sign their own tokens and provide their own information.
  Since JWTs are signed and not encrypted, any malefactor who receives access
  to a token can decode the Base64 format and read the tokens information in
  clear text.

  \textbf{Defensive Mechanism:}
  Properly signining the tokens with a strong algorithm prevents information
  from being tampered with.
  An attacker can still read the information in clear-text but can not forge
  their own tokens.
  LessPM uses RSASSA-PSS with Sha-512 to sign and encode tokens, decoding
  them with the keypair when received.
  This ensures integrity and authenticity of the JWT, as the signature is
  verified by the server.
  RSASSA-PSS is a robust and secure signature algorithm that provides protection
  against various attacks, such as collision attacks and length extension
  attacks.
  To further impose a level of security, LessPM takes advantage of different
  tokens for registration, authentication, and authorization.

  \item \textbf{JSON Web Encryption (JWE}

  \textbf{Weakness:}
  JSON Web Encryption are JWTs signed and encrypted using an algorithm for
  signing and encryption.
  However, if this encryption algorithm is not potent or weak (such as a
  Caesar Cipher), an attacker can break the encryption or even encrypt their own
  tokens.
  JWEs are also subject to scenarios such as lack of key rotation, insecure
  length of the encryption key and improper implementation (See
  Section~\ref{sec:futurework}).

  \textbf{Defensive Mechanism:}
  To combat these weaknesses, LessPM implements encryption partly inspired by
  the JWE standard.
  LessPM encrypts the token using AES-256, a strong encryption scheme capable
  of $2^{256}$ different keys.
  This ensures that the data is confidentially kept and protected from
  unauthorized access.
  While inspired, it is important to note that JWEs have not been properly
  implemented in LessPM (See Section~\ref{sec:futurework}).

  \item \textbf{Hashing Passwords \& Keys}

  \textbf{Weakness:}
  Hashing is a one-way process to convert information (such as passwords)
  into a fixed-size string of characters, typically a fixed-length hash value.
  However, the hashing process is susceptible to a malefactor using
  precomputed hash-values for large number of possible passwords, stored in a
  lookup table called a Rainbow table attack.
  Hashes are also vulnerable to dictionary attacks, and not being properly
  implemented without using a salt and preferable a pepper, or brute-force
  attacks.

  \textbf{Defensive Mechanism}
  LessPM takes advantage of the latest within public hashing functionality,
  through Argon2.
  Argon2 constructs a memory-hard and computationally expensive hash that
  provides protection against brute-force, rainbow table, dictionary and
  side-channel attacks by requiring a significant amount of computational
  resources and time to compute the hash.
  Finally, LessPM takes advantage of using both a random salt unique for each
  password and a pepper stored in the source code of 128-bit for both.
  This creates a higher threshold for a malefactor by requiring access to the
  database and the source code to be able to quickly compute a hash.
  The salt and pepper are added to the key of the AES-256

  \item \textbf{Password Authentication}

  \textbf{Weakness}
  A password is something a secret that a user knows.
  Secrets belonging to an individual will always be potentially accessible to
  a malefactor.
  There are multiple vectors that can be used, such as a user being careless
  and writing the password down on a piece of paper or storing the secret in an
  unencrypted file.
  Further, a password is required to be stored somewhere for a server to
  authenticate the user, preferably with an email for recovery.
  This creates two new vectors for a malefactor to exploit, the persisted
  storage on the server or the recovery process.

  \textbf{Defensive Mechanism}
  LessPM takes advantage of WebAuthn to avoid the usage of passwords to
  authenticate the user.
  The user is required to have two vectors for authentication; their
  authenticator device and the biometrics, which is the user itself.
  It is, however, important to mention that any authenticator device is
  vulnerable to being compromised.
  Should a device be compromised or infected with malicious software (Malware),
  it could be used to intercept or manipulate authentication requests.

  \item \textbf{Storing passwords in plaintext}

  \textbf{Weakness:}
  Storing a password can be done in plaintext in a database protected by a
  password.
  However, should an attacker get access to the database, all passwords and
  their plaintext are compromised.
  Storing the passwords in plaintext makes the information accessible to any
  individual with access to the database, which causes a privacy risk.

  \textbf{Defensive Mechanism:}
  LessPM encrypt all passwords with one of the strongest public symmetric
  encryption processes, AES-256.
  Each key for each password is unique, and consists of the 192-bit CID from
  WebAuthn generated when the user registered (See
  Section~\ref{subsec:password-encryption}).
  This CID is unique to each service the user is registered with.
  Along the 192-bit CID, 128-bit is used from a salt and 128-bit used from a
  pepper.
  The salt is stored with the entry in the database.
  Using both salt and pepper enhances the security of the derived key.

  \item \textbf{
    Cross-Site Scripting,
    Cross-Site Request Forgery
    \& Unauthorized Access}

  \textbf{Weakness:}
  Any HTTP server improperly configured is subject Cross-Site Scripting (XSS)
  and CSRF\@.
  XSS is a process where a malefactor could inject a malicious script from a
  different origin, and execute said script in the context of a user's browser.
  This could lead to a situation where a malefactor could get access tokens
  or cookies, or interact with the webpage a user is viewing through the
  script.
  CSRF is a type of security vulnerability where a malefactor tricks a user
  to unknowingly make unauthorized requests on a trusted website, such as a
  bank or similar.
  This can lead to actions being performed on a user's behalf unintentionally,
  without the user's consent, leading to unauthorized access.

  \textbf{Defensive Mechanism:}
  CORS is a measure that enforces a strict policy for which domains and services
  are permitted to access certain resources on the server.
  LessPM takes advantage of CORS by permitting the server itself and the
  client associated domain to access resources on the server.
  This is a preventive measure put in place to allow the communication
  between the client and the serve, even though they are running on different
  ports, and potentially different domains.
  This ensures that only authorized clients can access the server's resources,
  preventing unauthorized cross-origin requests and protecting against
  cross-site scripting (XSS) and cross-site request forgery (CSRF) attacks.

  \item \textbf{Cookies}
  \textbf{Weakness:}
  A cookie is vulnerable to many aspects of security.
  Improperly stored, a cookie can be accessed through JavaScript, sent to
  different domains, get hijacked, excessive expire time, or even poisoned.\footnote{
    Cookie Poisoning is the process where an attacker modifies the content of
    the cookie to inject malicious data or bypass security controls.
  }

  \textbf{Defensive Mechanism:}
  LessPM only uses one cookie, which contains the encrypted JWT\@.
  The cookie is protected through built-in browser-features such as
  restricted to the same origin that the cookie came from, and cannot be sent
  anywhere else, further preventing XSS of sensitive information\@.
  The cookie is expired after 15 minutes, which is extensive amount of time
  for a user to have authorized access to their passwords, before the need to
  reauthenticate their identity.
  Upon creation, LessPM makes sure that the cookie becomes set to secure.
  This prevents the cookie from being sent over an insecure HTTP connection,
  limiting it to HTTPS\@.
  Finally, the cookie is HttpOnly, so that the cookie can't be access through
  JavaScript, reducing the attack vector of SS further.

\end{enumerate}

%\todo[inline]{The preceeding section.}