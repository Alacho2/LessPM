
In today's world of rapidly evolving technology, it is crucial to have a
solid foundation in the underlying concepts and protocols that drive modern
systems.
This section aims to provide a comprehensive understanding of the key
technologies and principles that are relevant to LessPM\@.
As we explore the development and implementation of LessPM, our focus will be
on the key components, technologies, principles, and steps that form LessPM's
development process an encapsulation.

Our approach encompasses an explanation of the system architecture, as well as
an in-depth description of the key components, technologies, tools, and steps
that are involved in LessPM's encapsulation and development process to create
the prototype.
By thoroughly exploring these fundamental topics, we can better appreciate their
significance and application in the context of the implementation, design, and
architecture presented in LessPM\@.

One critical aspect of the development and system is its security and
robustness.
By providing a comprehensive account of the system development process, we aim
to enable readers to understand the technical aspects of our work and assess the
validity and relevance of our findings.

\subsection{Environment}\label{subsec:environment}
\input{methodology/environment}

\subsection{WebAuthn}\label{subsec:webauthn-methodology}
\input{methodology/webauthn}

\subsection{Cors}\label{subsec:cors}
Cross-Origin Resource Sharing (CORS) must be configured correctly when the
server and client are running separately on different ports.

When a web page tries to access a resource hosted on another domain, browsers
perform an additional request to the server, called a \texttt{``preflight''}.
The preflight request determines whether the
request that the web page is trying to make to the server is allowed.
This request is done through the \texttt{OPTIONS} method in HTTP and contains
some information about the origin, accepted Content-Type, and similar for the
actual request.

The server responds to this with what methods and headers are allowed, denying
the actual request from ever happening if the preflight is not successful.

We constructed a CORS \texttt{layer}\footnote{
  In this context, we referred to a layer as a wrapper around all other
  requests.
} which contained the two domains for the server and client, permitted
credentials\footnote{
  To pass the JWT token back and forth between the server
} and then permitted the two HTTP methods \texttt{POST} and \texttt{GET}.
We also ensured the \texttt{Content-Type, Authorization}, and \texttt{Cookie}
headers are permitted.

Any other methods or headers should abort the request in the preflight.

\subsection{Cookie}\label{subsec:cookie}
JavaScript can access and manipulate \texttt{Cookies}~\cite{he2019malicious}.
We utilized the browser's local cookie storage to attempt secure authentication
between requests.\footnote{
  The cookie storage in a browser is subject to any vulnerabilities that can be
  performed on an SQLite database while having access to the computer where it
  is running.
}
We attempted a couple of strategies listed below to fortify the cookie that
LessPM set in the browser against a malefactor:
\begin{itemize}
  \item \textbf{Strict SameSite}:
  This ensures that the cookie is safeguarded against Cross-Site Request Forgery
  (CSRF) attacks and remains restricted to its original origin domain.
  \item \textbf{Expires}:
  Once the system authenticated the user, it gave the cookie a Time-to-Live
  (TTL) mechanism similar to the JWE, which remained valid for only 15 minutes.
  \item \textbf{Secure}:
  We applied the \texttt{Secure} attribute to ensure that the cookie was only
  accessible through the HTTPS protocol.
  This protocol encrypts the data being sent back and forth between the client
  and the server, attempting to avoid eavesdroppers.
  \item \textbf{HttpOnly}:
  Setting HttpOnly tells the browser to make this cookie inaccessible through
  JavaScript.
  This property is important to mitigate session hijacking.
\end{itemize}

\subsection{Password Encryption}\label{subsec:password-encryption}
\input{methodology/encryption}

\subsection{Hashing}\label{subsec:hashing}
When we searched for a good key-derivation function, we first came across
Password-Based Key Derivation Function 2 (PBKDF2).
We saw PBKDF2 as a good solution for the project, but after researching the
topic further, we ended up with Argon2.

Argon2 is regarded by some to be more secure than PBKDF2 due to its modern
design considerations, including memory-hardness and protection against
side-channel attacks, which makes it more resistant to brute-force and rainbow
table attacks.
PBKDF2 offers to set an amount of iterations to construct the hash and which
pseudorandom function to use.

\subsubsection{Argon2}
Argon2 aims to provide a highly customizable function, tailored to the needs
of distinct contexts~\cite{argon2specs}.
Additionally, the design offers resistance to both time-memory trade-off
and side-channel attacks as a memory-hard function~\cite{argon2specs}.

The Key-Derivation Function (KDF) fills large memory blocks with pseudorandom
data derived from the input parameters, such as password and salt.\footnote{
  Argon2's intension is to have a 128-bit salt for all applications but this
  can be sliced in half, if storage is a concern~\cite{argon2specs}.
}
The algorithm then proceeds to process these blocks non-linearly for a specific
number of iterations~\cite{argon2specs}.

The KDF offers three configurations, depending on the environment where
the function will run and what the risk and threat models are, which we take
advantage of in LessPM\@.
These can be seen in Figure~\ref{fig:argon2conf}

\begin{figure}[htbp]
  \centering
  \begin{itemize}
    \item \textbf{Argon2d} is a faster configuration and uses data-depending
    memory access.
    This makes it suitable for cryptocurrencies and applications with little to
    no threat of side-channel timing attacks.\protect\footnotemark
    \item \textbf{Argon2i} uses data-independent memory access.
    This configuration is more suitable for password hashing and key-derivation
    functions.\protect\footnotemark
    ~The configuration is slower due to making more passes over the memory as
    the hashing progresses.
    \item \textbf{Argon2id} is a combination of the two, beginning with
    data-dependent memory access before transitioning to data-independent
    memory access after progressing halfway through the process.
  \end{itemize}
  \caption{The three configurations offered by Argon2~\cite{argon2specs}.}
  \label{fig:argon2conf}
\end{figure}

\footnotetext{
  Side-channel timing attacks analyze execution time variations in cryptographic
  systems to reveal confidential data, exploiting differences in time caused by
  varying inputs, branching conditions, or memory access patterns.
}
\footnotetext{
  Due to the nature of prioritizing security, LessPM uses the third
  configuration.
}

Since LessPM is required to run in as safe of an environment as possible,
Argon2's configuration option is an excellent solution.

Argon2, as a memory-intensive hashing function, demands substantial
computational resources from attackers attempting dictionary-\footnote{
  A dictionary attack is an approach where an attacker tries to find a hash by
  searching through a dictionary of pre-computed hashes or generating hashes
  based on a dictionary commonly used by individuals or businesses.
} or rainbow table attack.
This characteristic significantly hampers the feasibility of cracking
passwords using such attacks, constructing an ideal scenario for LessPM's
password vault.
The algorithm's customizability allowed us to adjust its behaviour
based on memory, parallelism, and iterations, catering to LessPM's security
requirements and performance needs.
All of these benefits contributed to why LessPM uses Argon2 instead of PBKDF2.

\subsubsection{Configuring Argon2}
Argon2's hashing output is dependable on
configurations~\cite{argon2specs}.\footnote{
  Dependable in this context refers to each configuration that can
  possibly be constructed.
  An instance of Argon2 with 256 Megabytes of \texttt{memory} will not return
  the same hash as 255 Megabytes.
  The same is true for the amount of \texttt{iterations} and
  \texttt{parallelism}.
}
Given that we emphasized security, we opted for the \texttt{Argon2id}
configuration, which gave us equal protection against side-channel and
brute-force attacks.

\todo[inline]{
  This paragraph needs to go somewhere in this section.

  As these configurations are crucial for computing the original hash, Argon2
  provides robust resilience against brute-force and side-channel attacks~\cite{
    argon2specs}.
  The resulting enhanced security makes Argon2 suitable for password storage and
  key-derivation in various applications and systems.

  In 2015, Argon2 won the Password Hashing
  Competition~\cite{passwordhashing}.\footnote{
    NIST's competition to find an encryption algorithm inspired the Password
    Hashing Competition, but it took place without NIST's endorsement.
  }

}

\todo[inline]{
  A part of Argon2's customizability is the offer to set the option for a
  required amount of memory to do the hashing.
}
These options would force a malefactor to use a specific amount of memory for
each attempt to construct the hash.
The only way a malefactor can get passed this requirement is to purchase more
memory.\footnote{
  As a side note, the increase in memory usage will scale as technology evolves
  and more memory becomes common.
}

For LessPM, we used 128 Megabytes of memory to construct the hash.\footnote{
  According to~\cite{argon2specs}, the reference implementation using Argon2d
  with 4Gb of memory and 8-degree parallelism, the hashing process should take
  0.5 seconds on a CPU with 2Gz. However, we were unsuccessful in seeing
  anywhere close to similar results.
}
We went for the default suggestion of two iterations to complement the memory.
To finalize the configuration, we added 8 degrees of parallelism since the
system where we developed it consists of 8 cores.~\footnote{
  The degree of parallelism is affected by how many cores a CPU
  contains~\cite{argon2specs}.
}

\todo[inline]{The following section}

\subsection{Security Analysis}\label{subsec:security-analysis}
The security of a passwordless password manager is of paramount importance to
protect sensitive user infromation and prevent unauthorized access.
In this subsection, we conduct a comprehensive security analysis, identifying
  potential attack vectors and outlining the defensive measures that have
  been implemented to mitigate tehse risks.

The defensive measures include industry-standard security protocols such as
  HTTPS, JWT/JWE, Argon2 hashing, salt and pepper techniques, CORS
  configuration, and secure cookie management.
Additionally, different JWTs are used for registration, authentication, and
  password creation/retrieval to minimize the risk of exposure.
These defensive measures collectively aim to provide a robust and secure
  architecture for LessPM, safeguarding against various threats and ensuring
  the confidentiality, integrity, and availability of user data.
\begin{enumerate}[label=$\blacktriangleright$]
  \item \textbf{HTTP}

  \textbf{Weakness:}

  Any server running HTTP (Hypertext Transfer Protocol) is passing data
  between a server and a connecting client.
  With HTTP, this data is unencrypted.
  A malefactor can eavesdrop this data, performing a man-in-the-middle attack,
  replacing information, reading tokens, perform header inections, Etc. with 
  this unencrypted traffic.

  \textbf{Defensive Mechanism:}

  Upgrading the HTTP connection to HTTPS ensures that communication between the
  client and server is encrypted through Transport Layer Security (TLS).
  It provides confidentiality and integrity of data transmitted over the
  network, making it more difficult for attackers to intercept or tamper with
  sensitive information.

  \item \textbf{JSON Web Tokens (JWT)}

  \textbf{Weakness:}

  JWTs are signed with a secret specific to the server.
  However, if this secret is discovered or leaked, a malefactor could use this
  information to sign their own tokens and provide their own information.
  Since JWTs are signed and not encrypted, any malefactor who receives access
  to a token can decode the Base64 format and read the tokens information in
  clear text.

  \textbf{Defensive Mechanism:}

  Properly signining the tokens with a strong algorithm prevents information
  from being tampered with.
  An attacker can still read the information in clear-text but can not forge
  their own tokens.
  LessPM uses RSASSA-PSS with Sha-512 to sign and encode tokens, decoding
  them with the keypair when received.
  This ensures integrity and authenticity of the JWT, as the signature is
  verified by the server.
  RSASSA-PSS is a robust and secure signature algorithm that provides protection
  against various attacks, such as collision attacks and length extension
  attacks.
  To further impose a level of security, LessPM takes advantage of different
  tokens for registration, authentication, and authorization.

  \item \textbf{JSON Web Encryption (JWE}

  \textbf{Weakness:}

  JSON Web Encryption are JWTs signed and encrypted using an algorithm for
  signing and encryption.
  However, if this encryption algorithm is not potent or weak (such as a
  Caesar Cipher), an attacker can break the encryption or even encrypt their own
  tokens.
  JWEs are also subject to scenarios such as lack of key rotation, insecure
  length of the encryption key and improper implementation (See
  Section~\ref{sec:futurework}).

  \textbf{Defensive Mechanism:}

  To combat these weaknesses, LessPM implements encryption partly inspired by
  the JWE standard.
  LessPM encrypts the token using AES-256, a strong encryption scheme capable
  of $2^{256}$ different keys.
  This ensures that the data is confidentially kept and protected from
  unauthorized access.
  While inspired, it is important to note that JWEs have not been properly
  implemented in LessPM (See Section~\ref{sec:futurework}).

  \item \textbf{Hashing Passwords \& Keys}

  \textbf{Weakness:}

  Hashing is a one-way process to convert information (such as passwords)
  into a fixed-size string of characters, typically a fixed-length hash value.
  However, the hashing process is susceptible to a malefactor using
  precomputed hash-values for large number of possible passwords, stored in a
  lookup table called a Rainbow table attack.
  Hashes are also vulnerable to dictionary attacks, and not being properly
  implemented without using a salt and preferable a pepper, or brute-force
  attacks.

  \textbf{Defensive Mechanism:}

  LessPM takes advantage of the latest within public hashing functionality,
  through Argon2.
  Argon2 constructs a memory-hard and computationally expensive hash that
  provides protection against brute-force, rainbow table, dictionary and
  side-channel attacks by requiring a significant amount of computational
  resources and time to compute the hash.
  Finally, LessPM takes advantage of using both a random salt unique for each
  password and a pepper stored in the source code of 128-bit for both.
  This creates a higher threshold for a malefactor by requiring access to the
  database and the source code to be able to quickly compute a hash.
  The salt and pepper are added to the key of the AES-256

  \item \textbf{Password Authentication}

  \textbf{Weakness:}

  A password is something a secret that a user knows.
  Secrets belonging to an individual will always be potentially accessible to
  a malefactor.
  There are multiple vectors that can be used, such as a user being careless
  and writing the password down on a piece of paper or storing the secret in an
  unencrypted file.
  Further, a password is required to be stored somewhere for a server to
  authenticate the user, preferably with an email for recovery.
  This creates two new vectors for a malefactor to exploit, the persisted
  storage on the server or the recovery process.

  \textbf{Defensive Mechanism:}

  LessPM takes advantage of WebAuthn to avoid the usage of passwords to
  authenticate the user.
  The user is required to have two vectors for authentication; their
  authenticator device and the biometrics, which is the user itself.
  It is, however, important to mention that any authenticator device is
  vulnerable to being compromised.
  Should a device be compromised or infected with malicious software (Malware),
  it could be used to intercept or manipulate authentication requests.

  \item \textbf{Storing passwords in plaintext}

  \textbf{Weakness:}

  Storing a password can be done in plaintext in a database protected by a
  password.
  However, should an attacker get access to the database, all passwords and
  their plaintext are compromised.
  Storing the passwords in plaintext makes the information accessible to any
  individual with access to the database, which causes a privacy risk.

  \textbf{Defensive Mechanism:}

  LessPM encrypt all passwords with one of the strongest public symmetric
  encryption processes, AES-256.
  Each key for each password is unique, and consists of the 192-bit CID from
  WebAuthn generated when the user registered (See
  Section~\ref{subsec:password-encryption}).
  This CID is unique to each service the user is registered with.
  Along the 192-bit CID, 128-bit is used from a salt and 128-bit used from a
  pepper.
  The salt is stored with the entry in the database.
  Using both salt and pepper enhances the security of the derived key.

  \item \textbf{
    Cross-Site Scripting,
    Cross-Site Request Forgery
    \& Unauthorized Access}

  \textbf{Weakness:}

  Any HTTP server improperly configured is subject Cross-Site Scripting (XSS)
  and CSRF\@.
  XSS is a process where a malefactor could inject a malicious script from a
  different origin, and execute said script in the context of a user's browser.
  This could lead to a situation where a malefactor could get access tokens
  or cookies, or interact with the webpage a user is viewing through the
  script.
  CSRF is a type of security vulnerability where a malefactor tricks a user
  to unknowingly make unauthorized requests on a trusted website, such as a
  bank or similar.
  This can lead to actions being performed on a user's behalf unintentionally,
  without the user's consent, leading to unauthorized access.

  \textbf{Defensive Mechanism:}

  CORS is a measure that enforces a strict policy for which domains and services
  are permitted to access certain resources on the server.
  LessPM takes advantage of CORS by permitting the server itself and the
  client associated domain to access resources on the server.
  This is a preventive measure put in place to allow the communication
  between the client and the serve, even though they are running on different
  ports, and potentially different domains.
  This ensures that only authorized clients can access the server's resources,
  preventing unauthorized cross-origin requests and protecting against
  cross-site scripting (XSS) and cross-site request forgery (CSRF) attacks.

  \item \textbf{Cookies}

  \textbf{Weakness:}

  A cookie is vulnerable to many aspects of security.
  Improperly stored, a cookie can be accessed through JavaScript, sent to
  different domains, get hijacked, excessive expire time, or even poisoned.\footnote{
    Cookie Poisoning is the process where an attacker modifies the content of
    the cookie to inject malicious data or bypass security controls.
  }

  \textbf{Defensive Mechanism:}

  LessPM only uses one cookie, which contains the encrypted JWT\@.
  The cookie is protected through built-in browser-features such as
  restricted to the same origin that the cookie came from, and cannot be sent
  anywhere else, further preventing XSS of sensitive information\@.
  The cookie is expired after 15 minutes, which is extensive amount of time
  for a user to have authorized access to their passwords, before the need to
  reauthenticate their identity.
  Upon creation, LessPM makes sure that the cookie becomes set to secure.
  This prevents the cookie from being sent over an insecure HTTP connection,
  limiting it to HTTPS\@.
  Finally, the cookie is HttpOnly, so that the cookie can't be access through
  JavaScript, reducing the attack vector of SS further.

\end{enumerate}

%\todo[inline]{The preceeding section.}