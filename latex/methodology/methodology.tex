Exploring the development and implementation of LessPM, a passwordless password
manager, our focus will be on the key components, technologies, and steps that
form the system's development process.
A crucial part of the development and system was its security and robustness.

Our approach encompasses an explanation of the system architecture, the
technologies and tools utilized and the development process to create the
prototype.
By providing a comprehensive account of the system development process, we aim
to enable readers to understand the technical aspects of our work as well
as to assess the validity and relevance of our findings.

\subsection{Environment}\label{subsec:environment}
To implement the system, we approached the development from a type-safety
environment.

\subsubsection{Server}
We chose Rust as the programming language for our backend, which provided
significant benefits regarding the software development environment.

Rust's emphasis on safety and performance allowed us to create a highly
secure and efficient environment for our implementation without the risks
typically associated with memory-related
vulnerabilities~\cite{rivera2019preserving}.
The built-in memory management and focus on concurrency ensures that the
software runs smoothly, which is crucial~\cite{fischer1985impossibility} when
dealing with sensitive user data.

Additionally, Rust's surrounding ecosystem is at rapid
growth~\cite{librs-stats}, containing a vast library of high-quality
crates\footnote{
  \texttt{Crate} is the Rust-specific name for a package or library.
}, which enables expeditious development and easy integration of various
functionality.
Utilizing Rust's distinctive features, the passwordless password manager
provides enhanced security and reliability in the context of user authentication
~\cite{rivera2019preserving}, showcasing the benefits of utilizing a modern
programming language.

The backend ran an instance of an HTTPS server, serving as a wrapper for the
sensitive data.\footnote{
  We took advantage of the Authorization header during development, as specified
  in RFC 7519.
  However, the framework we used for the server required us to expose the usage
  of \texttt{Authorization header} to access it in the client.
  See Section~\ref{sec:futurework} for further explanation.
}
The Chromium developers mandate this constraint to guarantee that the pertinent
API is invoked exclusively within a secure context~\cite{webdev2021credential}.
During development, we established a secure connection by using a self-signed
certificate for the \texttt{``localhost''} domain.

To serve as persistent storage to maintain the passwords, user accounts, and
other related data, LessPM adopted MongoDB\@.
MongoDB allowed us to use their NoSQL architecture, permitting storing
Object-like structures~\cite{mongodb2021nosql}.

\subsubsection{Client}
An essential part of the implementation was to create a viable client that could
function as a visual entry point to the server.
For the simplicity of the project, we chose React as a framework.
React is a JavaScript library for building user interfaces, offering an
efficient and flexible approach to web development.
We focused on following The Law of Demeter (LoD)~\cite{lieberherr1990assuring},
and using a least-knowledge principle.

This approach ensured that the client only retained the necessary information
to function, maintaining no knowledge of the server or its implementation
between each performed request.

As is customary when developing a system containing authentication and
authorization, we took advantage of JWT/JWE
(Section~\ref{subsec:json-web-tokens})
to retain some information to authorize the client between requested resources.
We strongly encrypted the Base64-encoded data passed between the server and
client using AES-256 (Section~\ref{subsec:aes}).

We took advantage of React's ability to construct a single-page application with
no routing capabilities, avoiding the possibility of utilizing any URL tampering
or manipulation\footnote{
  Malefactors can perform URL Manipulation, which involves modifying a URL to
  request resources that would otherwise be inaccessible to a user.
} to attempt privilege escalation or accessing data restricted from them.

Further, the server checked and verified the token before proceeding with any
requests made to it.
This information is updated and inspected between each
re-render~\cite{react-component} of the client.

When the development of the project first started, we had a strong wish for the
client to be an extension for Chromium-based browsers.\footnote{
  In the client's project folder are traces of a manifest.json file and build
  scripts to have the client run in an extension.
}
However, we quickly discovered that the Rust cargo used to perform WebAuthn
requests did not implement this support.
We reported this issue
\href{https://github.com/kanidm/webauthn-rs/issues/288}{upstream to the authors}
of the cargo, and we will continue to work with the authors to ensure a proper
implementation of this functionality in the future.

\subsection{WebAuthn}\label{subsec:webauthn-methodology}
We used WebAuthn to perform passwordless authentication.
As an open standard, WebAuthn aims to provide a key-based authentication scheme
to strongly authenticate users.
When users sign up for a new service, their device generates a new key-pair
(See Section~\ref{subsec:webauthn}).

WebAuthn attempted to mitigate phishing, man-in-the-middle, and brute-force
attacks through its intuitive design~\cite{webauthn_level_2}.
By leveraging the increasing market of smartphones with
biometrics~\cite{statista-biometric-transactions}, WebAuthn becomes a natural
extension in terms of authentication.

\subsubsection{Registration}\label{subsubsec:metho-registration}
When a user tried registering in LessPM, we first check whether a user with a
similar name existed.
We would deny the registration if the user existed.
If no user had that name within the system, we generated a unique ID using UUID
V4 and started the necessary Registration Ceremony.

We generated a JWE during this process, which was signed with RSASSA-PSS using
SHA-512 before getting encrypted with AES-256
(See Section~\ref{sec:futurework}).
This claim is then attached to the request's \texttt{Authorization} header,
along with the Creation options from WebAuthn
(See Section~\ref{subsec:webauthn}).

The \texttt{expiration} time for this claim is set to one minute to allow the
user some time to authenticate.\footnote{
  WebAuthn describes a timeout performed within the system. In our case, this
  timeout is one minute.
  However, we chose to add this extra step to secure the project further, and JWEs require an expiry time. See Section~\ref{subsec:json-web-tokens}.
}
The claim expired after this minute, and the user would then have to restart the
process.
This expiration timer was a decision we made to emphasize security within LessPM
further.

When the response returned to the user, LessPM used the browser's built-in
WebAuthn API to prompt the user for their authentication
(See Section~\ref{subsec:webauthn}).
At this point, it is entirely up to the user to decide what device to use to
authenticate.
We used an Apple iPhone 13 Pro Max, a Samsung S21, and a Samsung Galaxy A52 to
test authentication.\footnote{
  Other alternatives included a YubiKey, NitroKey, Etc.
}

We scanned the QR codes prompted through our phones, which initiated the
key-pair generation on the device after a successful facial recognition.
\footnote{
  There is a question of concern that photography can bypass facial recognition.
  Apple uses built-in sensors to scan depth, colours and a dot projector to
  create a 3D scan of a person's face.
  However, this approach prevents the use of photography to authenticate through
  their FaceID and TrueDepth technology~\cite{apple-support}.
}
The public key then gets transmitted to the browser and sent to the Relying
Party through a new request.

Before the request reaches the Relying Party, an authentication middleware
checks for the JWE sent earlier and denies the request with an
\texttt{Unauthorized} HTTP status code if the request is invalid.
\footnote{
  Validity in this context means not timed out, tampered with, or similar.
}
If WebAuthn can validate the key and metadata sent with the request, the user
gets stored in the database, along with the UUID generated.

\subsubsection{Authentication}\label{subsubsec:metho-authentication}
Authentication worked similarly to the registration process.
Upon receiving an incoming request, the server checked the database.
The server immediately rejected the request if the user did not exist in the
database.

Further, the server attempted an Authentication Ceremony by collecting the
public key from the database.
Upon validation\footnote{
  Validation in this context only means that the key stored in the database is
  valid.
} of the public key, the server creates a new JWE, which also receives an
\texttt{expiry} of one minute for the user to authenticate (See
Section~\ref{subsec:webauthn}), before sending that and the challenge in the
response.
We then prompt the user to authenticate with their original authenticator
that they used in the registration step, having the authenticator sign the
challenge before performing a new request to the server with the signed
challenge.
The server considered the user authenticated if the Relying Party accepted the
signed challenge.

Finally, the user had a 15-minute timeframe to perform the necessary activity
within LessPM\@.
The specification for JWT does not specify upper- or lower bounds for this
value ~\cite{RFC7519}.

\subsubsection{Password Creation \& Retrieval}\label{subsubsec:creation-and-retrieval}
Passwords are sensitive in nature, so it seems only natural in a security
context to enforce an extra level of authentication upon retrieving and creating
one unique password.\footnote{
  We retrieved a complete list of the user's passwords upon successful authentication.
  The hashed version of the password is stripped of the returned values to protect and enforce security.
}

A user is presented with the following options when they initiate a password
creation:

\begin{itemize}
  \item \textbf{User Identifier}: An identification that the user wants to
  associate with the password entry they are storing.
  Such as a username, phone number, or email.
  \item \textbf{Website}: A URL or similar where the password belongs.
  \item \textbf{Password}: The user is prompted with the input to create a
  strong password automatically, choosing options such as numbers, special
  symbols, smaller or larger characters, and the length.
  As an option, the user was also permitted to construct their password but
  warned by a warning saying that this option is less secure.
\end{itemize}

As a final step before a password is created and stored, the user is prompted to
reauthenticate with their AD\@.
The password is created and stored in the database if this authentication
process is successful.

Users needed to make a new authentication request when they wanted to retrieve
the plaintext version of the password.
This step is done in part to validate the user's presence\footnote{
  This approach is also used in password managers on phones to avoid situations
  where a user might have left their computer unlocked.
} but also to gather the necessary bits for the key-reconstruction
(See Section~\ref{subsec:password-encryption}).

\subsection{Cors}\label{subsec:cors}
Cross-Origin Resource Sharing (CORS) must be configured correctly when the
server and client are running separately on different ports.

When a web page tries to access a resource hosted on another domain, browsers
perform an additional request to the server, called a \texttt{``preflight''}.
The preflight request determines whether the
request that the web page is trying to make to the server is allowed.
This request is done through the \texttt{OPTIONS} method in HTTP and contains
some information about the origin, accepted Content-Type, and similar for the
actual request.

The server responds to this with what methods and headers are allowed, denying
the actual request from ever happening if the preflight is not successful.

We constructed a CORS \texttt{layer}\footnote{
  In this context, we referred to a layer as a wrapper around all other
  requests.
} which contained the two domains for the server and client, permitted
credentials\footnote{
  To pass the JWT token back and forth between the server
} and then permitted the two HTTP methods \texttt{POST} and \texttt{GET}.
We also ensured the \texttt{Content-Type, Authorization}, and \texttt{Cookie}
headers are permitted.

Any other methods or headers should abort the request in the preflight.

\subsection{Cookie}\label{subsec:cookie}
JavaScript can access and manipulate \texttt{Cookies}~\cite{he2019malicious}.
We utilized the browser's local cookie storage to attempt secure authentication
between requests.\footnote{
  The cookie storage in a browser is subject to any vulnerabilities that can be
  performed on an SQLite database while having access to the computer where it
  is running.
}
We attempted a couple of strategies listed below to fortify the cookie that
LessPM set in the browser against a malefactor:
\begin{itemize}
  \item \textbf{Strict SameSite}:
  This ensures that the cookie is safeguarded against Cross-Site Request Forgery
  (CSRF) attacks and remains restricted to its original origin domain.
  \item \textbf{Expires}:
  Once the system authenticated the user, it gave the cookie a Time-to-Live
  (TTL) mechanism similar to the JWE, which remained valid for only 15 minutes.
  \item \textbf{Secure}:
  We applied the \texttt{Secure} attribute to ensure that the cookie was only
  accessible through the HTTPS protocol.
  This protocol encrypts the data being sent back and forth between the client
  and the server, attempting to avoid eavesdroppers.
  \item \textbf{HttpOnly}:
  Setting HttpOnly tells the browser to make this cookie inaccessible through
  JavaScript.
  This property is important to mitigate session hijacking.
\end{itemize}

\subsection{Password Encryption}\label{subsec:password-encryption}
A password can be stored and hashed using a \texttt{salt} in a typical
authentication scheme.
When trying to authenticate, the user would provide their UID and password.
These values are collected from the database and checked with the random
salt\footnote{
  Salting is the process of adding a randomly generated string consisting of
  arbitrary characters to the password before creating a hash~\cite{Kharod2015}.
} that was generated when the user registered.

Securing the applicant's passwords made the process more complicated than the
one described above.
Furthermore, since the passwords in a password manager should be a randomly
generated string unknown to the applicant, we cannot hash it and compare the
input from the user.

We decided on the AES-256 (see Section~\ref{subsec:aes}), as a high form of
encryption is paramount to securing the passwords.
AES requires a 256-bit key to encrypt and decrypt the data.
Since the CID generated by WebAuthn is unique and random for each application
and device, this serves as a basis for constructing the key.

We based the key for each password on the following premise:
\begin{enumerate}
  \item
  We take advantage of the fact that each CID is unique in every application
  (see Section~\ref{subsec:webauthn}).
  We therefore used 192-bits of the string that is the CID\@, converting it to
  integers.
  Since every CID is unique depending on the device, we generated padding to
  reach the remaining difference when the CID does not contain 192-bit.
  \item
  We appended each key with a random 128-bit salt of integers and stored these
  bits with the entry in the database.
  \item
  Then we add a 128-bit of pepper collected from the environment variable to
  finish it.
\end{enumerate}
We used this 448-bit as the input for the key-derivation function,
Argon2 (See Section~\ref{subsec:hashing-through-argon2}).
Upon hashing, each key is also subject to a 128-bit salt explicitly generated
for the key.

\subsection{Hashing}\label{subsec:hashing}
When we searched for a good key-derivation function, we first came across
PBKDF2.
We saw this as a good solution for the project, but after researching the topic
further, we ended up with Argon2.

Since LessPM is required to run in as safe of an environment as possible,
Argon2's configuration option is an excellent solution.

\subsubsection{Configuring Argon2}
Argon2's hashing output is dependable on
configurations~\cite{argon2specs}.\footnote{
  Dependable in this context refers to each configuration that can
  possibly be constructed.
  An instance of Argon2 with 256 Megabytes of \texttt{memory} will not return
  the same hash as 255 Megabytes.
  The same is true for the amount of \texttt{iterations} and
  \texttt{parallelism}.
}
Given that we emphasized security, we opted for the \texttt{Argon2id}
configuration, which gave us equal protection against side-channel and
brute-force attacks.

A part of the brilliant aspect that Argon2 offered is the option to set a
required amount of memory to do the hashing.
These options would force a malefactor to use a specific amount of memory for
each attempt to construct the hash.
The only way a malefactor can get passed this requirement is to purchase more
memory.\footnote{
  As a side note, the increase in memory usage will scale as technology evolves
  and more memory becomes common.
}

For LessPM, we used 128 Megabytes of memory to construct the hash.\footnote{
  According to~\cite{argon2specs}, the reference implementation using Argon2d
  with 4Gb of memory and 8-degree parallelism, the hashing process should take
  0.5 seconds on a CPU with 2Gz. However, we were unsuccessful in seeing
  anywhere close to similar results.
}
We went for the default suggestion of two iterations to complement the memory.
To finalize the configuration, we added 8 degrees of parallelism since the
system where we developed it consists of 8 cores.~\footnote{
  The degree of parallelism is affected by how many cores a CPU
  contains~\cite{argon2specs}.
}

\subsection{JWT \& JWE}\label{subsec:jwt}
The JWT contained data we could use to validate an authenticated user between
HTTP requests, which we encoded as a URL-safe base64 string
(See Section~\ref{subsec:json-web-tokens}).
According to~\cite{RFC7519}, these should be attached to the authorization part
of a request, along with a \texttt{Bearer} part.
These tokens are cryptographically signed with RSASSA-PSS using SHA-512 with a
key-pair stored on the server to avoid forgery.

For each step in registration~\ref{subsubsec:metho-registration},
authentication~\ref{subsubsec:metho-authentication}, and
password creation/retrieval~\ref{subsubsec:creation-and-retrieval}, different
tokens with different information are constructed, verified, and
discarded.\footnote{
  The token for password creation/retrieval is the same as verifying that a user
  is signed in and authorized to create entries on behalf of the user.
}
We opted for this approach so that an exposed token could not serve as more than
one entry point for one of the steps.

By default, these tokens are not encrypted.
It is out of the question to unnecessarily expose any sensitive details about
the server's inner workings.
Therefore, we decided to incorporate a part inspired by JWE.\footnote{
  To properly implement JWE, metadata should be encoded into the token, such as
  what algorithm performs the encryption~\cite{rfc7516}. For further
  explanation, see Section~\ref{sec:futurework}.
}
Before any token is attached to a response from the server, the token is
encrypted using AES-256\@.
The Base64 gets encrypted into a ciphertext and then turned into a new Base64
encoding.
An example of this can be seen in ~Appendix\ref{subsec:base64-and-ciphertext}.

We decoded the Base64, decrypted the ciphertext, and decoded the JWT-Base64 to
reconstruct the claim when the server received a new request.
We used this claim to gather details about the user who made the request and
responded accurately to the request accordingly.
