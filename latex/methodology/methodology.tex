Exploring the development and implementation of LessPM, a passwordless password
manager, our focus will be on the key components, technologies, and steps
that form the system's development process.
A crucial part of the development and system is its security and robustness.

Our approach encompasses an explanation of the system architecture, the
technologies and tools utilized and the development process to create the
prototype.
By providing a comprehensive account of the system development process, we
aim to enable readers to understand the technical aspects of our work, as well
as to assess the validity and relevance of our findings.

\subsection{Environment}\label{subsec:environment}
To implement the system, we went to approach the development from a type-safety
environment.

\subsubsection{Server}
We chose Rust as the programming language for our backend which provided
significant benefits in terms of the software development environment.

Rust's emphasis on safety and performance allowed us to create a highly
secure and efficient environment for our implementation, without the risks
typically associated with memory-related
vulnerabilities~\cite{rivera2019preserving}.
The built-in memory management and focus on concurrency ensures that our
software runs smoothly, which is crucial~\cite{fischer1985impossibility}
when dealing with sensitive user data.

Additionally, Rust's surrounding ecosystem is rapidly
growing~\cite{librs-stats}, containing a vast library of high-quality
crates\footnote{
  \texttt{Crate} is the Rust-specific name for package or library.
}, which enables rapid development and easy integration of various
functionality.
Utilizing Rust's distinctive features, the passwordless password manager provides
enhanced security and reliability in the context of user authentication
~\cite{rivera2019preserving}, showcasing the benefits of utilizing a modern
programming language.

The backend is running an instance of an HTTPS server, serving as a wrapper
for the sensitive data.\footnote{
  During development, we took advantage of the Authorization header, as is
  specified with in RFC 7519.
  However, the framework that we used for the server requires to specifically
  expose the usage of \texttt{Authorization header} in order to access it in the
  client.
  See Section~\ref{sec:futurework} for further explanation.
}
The Chromium developers mandate this constraint to guarantee that the pertinent
API is invoked exclusively within a secure context~\cite{webdev2021credential}.
During development, the secure connection was performed through a self-signed
certificate for the \texttt{``localhost''} domain.

To serve as a persistent storage to maintain the passwords, user accounts,
and other related data, LessPM adopted MongoDB\@.
MongoDB allowed us to take use of their NoSQL architecture, permitting
storing Object-like structures~\cite{mongodb2021nosql}.

\subsubsection{Client}
An important part of the implementation is to create a viable client that can
function as a visual entry-point to the server.
For simplicity of the project, we chose React as a framework.
React is a JavaScript library for building user interfaces, offering a
efficient and flexible approach to web development.
We focused on following The Law of Demeter (LoD)~\cite{lieberherr1990assuring},
and using a least-knowledge principle.

This assures that the client only retains the necessary information needed to
function, having no knowledge of the server nor its implementation between each
performed request.

As is customary when developing a system containing authentication and
authorization, we are taking advantage of JWT/JWE
(Section~\ref{subsec:json-web-tokens})
to retain some information, in order to authorize the client between
requested resources.
The Base64-encoded data that is passed between the server and client is
strongly encrypted through AES-256 (Section~\ref{subsec:aes}).

We took advantage of React's ability to construct a single-page application with
no routing capabilities, avoiding the possibility of utilizing any kind of URL
tampering or manipulation\footnote{
  URL Manipulation is a technique performed by malefactors where a URL can be
  modified to request resources that should otherwise be inaccessbile to a user.
} to attempt privilege escalation.
Further, every time a request is performed to the server, the token gets
checked and verified before continuing the request.
This information is updated and check between each
re-render~\cite{react-component} of the client.

When the development of the project first started, we had a strong wish of
running the client in an extension for Chromium-based browsers.\footnote{
  In the client's folder of the project, you can see traces of a
  manifest.json file, as well as build scripts to have the client run in an
  extension.
}
However, as we quickly discovered, the Rust-cargo used to perform WebAuthn
requests does not have this support implemented.
This issue was reported
\href{https://github.com/kanidm/webauthn-rs/issues/288}{upstream to the authors}
of the cargo, and we will continue to work with the authors to assure a proper
implementation of this functionality in the future.

\subsection{WebAuthn}\label{subsec:webauthn-methodology}
We used WebAuthn to perform the passwordless authentication.
As an open standard, WebAuthn aims to provide a key-based authentication
scheme in order to strongly authenticate users.
Keys are generated on a device in a user's possession and each time a
user signs up for a new service, a new key gets randomly generated on the
user's device (See Section~\ref{subsec:webauthn}).

WebAuthn is intuitively designed to attempt to mitigate phishing,
man-in-the-middle, and brute-force attacks~\cite{webauthn_level_2}.
By leveraging the increasing market of smartphones with
biometrics~\cite{statista-biometric-transactions}, WebAuthn becomes a natural
extension in terms of Authentication.

\subsubsection{Registration}
When a user tries to register in LessPM, the first thing we do is check
whether a user with a similar name exists.
We deny the registration if the user exists.
If there are no user with that name within the system, we generate a unique ID
using UUID V4, and starts the necessary Registration Ceremony.

We generate a JWE during this process, which is signed with RSASSA-PSS
using SHA-512 before getting encrypted with AES-256 (See
Section~\ref{sec:futurework}).
This claim is then attached to the request's \texttt{Authorization} header,
along with the Creation options from WebAuthn (See
Section~\ref{subsec:webauthn}).
The \texttt{expiration} time for this claim is set to one minute to allow the
user some time to perform the authentication.\footnote{
  WebAuthn describes a timeout performed within the system. In our case, this
  timeout is one minute.
  However, we elected this extra approach to further secure the project, and
  JWEs need a timeout. See Section~\ref{subsec:json-web-tokens}.
}
The claim expires after this minute and the user will then have to restart the
process.
This was a decision we made to further emphasize security within LessPM\@.

When the response comes back to the user, LessPM uses the browser built-in
WebAuthn API to prompt the user for their authentication (See
Section~\ref{subsec:webauthn}).
At this point, it is entirely up to the user how they decide to perform the
authentication.
In our case, we used an Apple iPhone 13 Pro Max, a Samsung S21, and a Samsung
Galaxy A52 to test authentication.\footnote{
  Other alternatives would include a YubiKey, NitroKey, etc.
}

We scanned the QR codes prompted through our phones, which initiates the
key-pair generation on the device after a successful facial recognition.
\footnote{
  There is a question of concern that facial recognistion can be bypassed
  through using a photography.
  Apple takes advantage of a built-in sensors to
  scan depth, colors, and a dot projector to create a 3D scan of a person's
  face.
  This prevents usage of a photography to perform authentication through
  their FaceID and TrueDepth technology~\cite{apple-support}.
}
The public key then gets transmitted to the browser and sent to the Relying
Party through a new request.

Before the request reaches the Relying Party, there is an authentication
middleware, which checks for the JWE that got sent earlier and denies the
request with an \texttt{Unauthorized} status code if the request is not valid.
\footnote{
  Validity in this contex means not timed out, tampered with, or similar.
}
The user is then stored in the database if WebAuthn can validate the key and
metadata sent with teh request, and then the user gets stored in the database,
along with the UUID generated.

\subsubsection{Authentication}
Authentication is quite similar to the registration process.
The database gets checked upon an incoming request to the server.
The server immediately rejects the request if the user does not exist in the
database.

Further, the server attempts an Authentication Ceremony by collecting the
public key from the database.
Upon validation\footnote{
  Validation in this context only means that the key stored in the database
  is a valid key.
} of the public key, the server creates a new JWE, which also receives an
\texttt{expiry} of one minute for the user to authenticate (See
Section~\ref{subsec:webauthn}), before sending that and the challenge in the
response.
We then prompt the user to authenticate with their original authenticator
that they used in the registration step, having the authenticator sign the
challenge before performing a new request to the server with the signed
challenge.
The user is considered authenticated if the Relying Party accepts the signed
challenge.

Finally, the user then has a 15-minute timeframe to perform necessary
activity within the server.
The specification for JWT does not specify bounds for this value~\cite{RFC7519}.

\subsubsection{Password Creation \& Retrieval}\label{subsubsec:creation-and-retrieval}
Passwords are sensitive in nature, and so it seems only natural in a security
context to enforce an extra level of authentication upon retrieving and
creating one individual password.\footnote{
  As soon as the user is authenticated, we retreieve a full list of these
  passwords.
  The actual password is stripped off of the returned values so to protect
  and enforce security.
}

A user is presented with the following options when they initiate a password
creation:

\begin{itemize}
  \item \textbf{User Identifier}: An identification that the user wants to
  associate with the password entry they are storing.
  \item \textbf{Website}: A url or similar where the password belongs.
  \item \textbf{Password}: The user is prompted with the input to create a
  strong password automatically, choosing options such as numbers, special
  symbols, smaller or larger characters, and the length.
  As an option, the user is also permitted to construct their own password,
  but prompted by a warning saying that this option is less secure.
\end{itemize}

As a final step before a password can is created and stored, the user is
prompted to reauthenticate with their AD\@.
If this authentication process is performed successfully, the password is
created and stored in the database.

A new authentication request is needed in the situations where the user wants to
retrieve the plaintext version of the password.
This is done in part to validate the user's presence\footnote{
  To avoid situations where a user might have left their computer in an
  unlocked state.
} but also to gather the necessary bits of the key-reconstruction (See
Section~\ref{subsec:password-encryption}).

\subsection{Cors}\label{subsec:cors}
With the server and client running separately on different ports, Cross-Origin
Resource Sharing (CORS) needed to be configured correctly.

When a web page tries to access a resource hosted on another domain, browsers
perform an additional request to the server, called a \texttt{``preflight''}.
The preflight request is responsible for determining whether the actual
request that the web page is trying to make to the server is allowed.
This request is done through the \texttt{OPTIONS} method in HTTP, and contain
some information about the origin, accepted Content-Type, and similar of the
actual request.
The server response to this with what methods and headers are allowed,
denying the actual request from ever happening if the preflight is not
successful.

We constructed a CORS \texttt{layer}\footnote{
  A layer is referred to in this context as a wrapper around all other requests.
} which contained the two domains for the server and client, including
credentials\footnote{
  To pass the JWT token back and forth between the server
} and then permitting the two HTTP methods \texttt{POST} and \texttt{GET}.
We made sure the \texttt{Content-Type, Authorization}, and \texttt{Cookie}
headers are permitted.

Any other methods or headers should abort the request in the preflight.

\subsection{Cookie}\label{subsec:cookie}
JavaScript can access and manipulate \texttt{Cookies}~\cite{he2019malicious}.
We are utilizing the browser's local cookie storage to attempt secure
authentication between requests.\footnote{
  The cookie storage in a browser is subject to any vulnerabilities that can
  be performed on a SQLite database while having access to the computer where
  it is running.
}
Attempting a couple of strategies listed below, we aim to fortify the cookie
that LessPM sets in the browser, against a malefactor:
\begin{itemize}
  \item \textbf{Strict SameSite}:
  This ensures that the cookie is protected against Cross-Site Request
  Forgery (CSRF) and inaccessible to domains of other origins than the one
  where the cookie got sent from.
  \item \textbf{Expires}:
  Since the JWE is only good for 15 minutes after the user authenticated, the
  cookie gets a similar Time-to-Live (TTL) mechanism.
  \item \textbf{Secure}:
  Making sure that a cookie is only transmitted over a secure connection
  through HTTPS\@.
  This encrypts the data being sent back and forth between the client and
  the server, attempting to avoid eavesdroppers.
  \item \textbf{HttpOnly}:
  Setting HttpOnly tells the browser to make this cookie inaccessible through
  JavaScript.
  This is important to avoid session hijacking.
\end{itemize}

\subsection{Password Encryption}\label{subsec:password-encryption}
A password can be stored and hashed using a \texttt{salt} in a typical
authentication scheme.
The user will provide their UID along with their password, this will get
collected from the database and checked with a random salt\footnote{
  Salting is the process of adding a randomly generated string consisting of
  arbitrary characters to the password before creating a hash~\cite{
    Kharod2015}.
} that was generated when the user registered.

This complicates the process compared to what is described above, since
the passwords should be a randomly generated string that is unknown to the
applicant, we cannot hash it and compare the input from the user.
We decided on the AES-256 (See Section~\ref{subsec:aes}), as a high form of
encryption is paramount to secure our passwords.
AES requires a 256-bit key to encrypt and decrypt the data.
Since the CID generated by WebAuthn is unique and random for each application,
this serves as a basis to construct the key.

The key for each password is based on the following premise:
\begin{enumerate}
  \item
  We take advantage of the fact that each CID is unique in every
  application (See Section~\ref{subsec:webauthn}). So we grab 192-bits of the
  string that is the CID\@.
  This string is converted to integers.
  Since every CID is unique depending on device, we generate a padding in the
  situations where the key does not contain 192-bit to reach the remaining
  difference.
  \item
  Each key consists of a random salt of 128-bit of integers.
  These numbers are stored with the entry in the database.
  \item
  Then we add 128-bit of pepper which is collected from the environment
  variable to finish it off.
\end{enumerate}
These 448-bit are then used to serve as the input for the key-derivation
function, Argon2 (See Section~\ref{subsec:hashing-through-argon2}).

\subsection{Hashing}\label{subsec:hashing}
When searching for a good key-derivation function, we first came across PBKDF2.
We saw this as a good solution for the project but after performing more
research into the topic, we ended up with Argon2.
Since LessPM is required to run in as safe of an environment as possible,
Argon2's configuration option seemed like the perfect solution.
Upon hashing, each key is also subject to a 128-bit salt generated
specifically for the key.

\subsubsection{Configuring Argon2}
Argon2's hashing output is dependable on configurations~\cite{argon2specs}.\footnote{
  Dependable in this context is referring to each configuration that can
  possibly be constructed.
  An instance of Argon2 with 256 Megabyte of \texttt{memory} will not return the
  same hash as 255 Megabyte.
  The same is true for amount of \texttt{iterations} and \texttt{parallelism}.
}
Given that we emphasize security, we opted for the \texttt{Argon2id}
configuration, giving us equal protection against side-channel and brute
force attacks.

A part of the brilliant aspect that Argon2 has to offer is the option to set
a required amount of memory to do the hashing.
This forces a malefactor to use a specific amount of memory for each attempt
at constructing the hash.
The only way a malefactor can get passed this requirement is to purchase more
memory.\footnote{
  As a sidenote, we imagine that the increase of memory usage will scale as
  technology evolves and more memory is installed in computers.
}

For LessPM, we are using 128 Megabyte of memory when constructing the hash.\footnote{
  According to~\cite{argon2specs}, the reference implementation using Argon2d
  with 4Gb of memory and 8 degree pararellism should let the hashing process
  take 0.5 seconds on a CPU with 2Gz. However, we were unsuccessful in seeing
  anywhere close to similar results.
}
We went for the default suggestion of two iterations to compliment the memory.
To finalize the configuration, we added 8 degree of parallelism, since the
system where we developed it consists of 8 cores~\footnote{
  The degree of parallelism is affected by many cores a CPU
  contains~\cite{argon2specs}.
}

%\subsubsection{Hashing AES-key}\label{subsubsec:hashing-aes-key}

\subsection{JWT \& JWE}\label{subsec:jwt}
A JWT is a base64-encoded string containing some data that can be used to
validate an authenticated user between HTTP-requests (See
Section~\ref{subsec:json-web-tokens}).
According to~\cite{RFC7519}, these should be attached to the authorization
part of a request, along with a \texttt{Bearer} part.
These tokens are cryptographically signed with RSASSA-PSS using SHA-512 with
a key-pair stored on the server to avoid forgery, before being encoded and to a
Base64-encoded string.
For each step in registration~\ref{subsubsec:registration},
authentication~\ref{subsubsec:authentication}, and
password creation/retrieval~\ref{subsubsec:creation-and-retrieval}, different
tokens with different information are constructed, verified, and
discarded.\footnote{
  The token for password creation/retrieval is the same as being verified
  that a user is signed in authorized to create entries on behalf of the user.
}

The tokens are not encrypted by default.
It is out of the question to expose any sensitive details about the server's
inner workings unnecessarily.
Therefore, we decided to incorporate a part inspired from JWE.\footnote{
  In a proper implementation of JWE, some metadata about the algorithm should
  be encoded into the token, such as what algorithm is used to perform the
  encryption~\cite{rfc7516}. For further expansion, see
  Section~\ref{sec:futurework}.
}
Before any token is attached to a response from the server, the token is
encrypted using AES\@.
The Base64 gets encrypted into a ciphertext and then turned into a new Base64
encoding.
An example of this can be found in~\ref{subsec:base64-and-ciphertext}.
We decode the Base64, decrypt the ciphertext, and then decode the JWT-Base64 to
reconstruct the claim when a new request is performed to the server.
This claim is then used to gather any details about the user that performed
the request to further respond accurately to the request.

% Content served over HTTPS through a self-signed certificate
% Axum as a framework to serve HTTP-content
% Cors configuration X
% Preflight-mention to the client X
% Allow authorization and cookie X
% cookie stored in HttpOnly (inaccessible to JS). And expiry time which is
% the same as the JWT. X
% JWT - you only have one minute to login after the request is performed. RSASSA-PSS using SHA-512
% Find some information about the JWT and use as a reference to talk about the transiton to JWE
% From JWT -> JWE
% - For security purposes, there should have been a new key for EACH JWT
% process (future work)
%
% There are 15 minutes to interact and do what you want after you're signed
% in. X
% Password is copiable from the client but does disappear after 15 seconds.
% The server acts as a one source of truth, client is ONLY rendering and doesn't store anything
% (other than the cookie)

% From PBKDF2 (SHA256) to Argon2
% Argon configuration related to my system
% Security over usability (In this case)

% A longer text about WebAuthn, part of the FIDO-2 standard, a validator key that is UNIQUE across all registrations
% - makes it more difficult to track (suseptiable to email and the likes still).
% The key is stored in the database with the user

% After the key construction, we generate a salt of 96 bit. This salt gets mixed
% into the Argon2 hash.
% This constructs the hash, and the hash acts as the key for AES, so it is
% random.

% We use this HASH as the key for AES256_GCM to encrypt the data (password)
% encoding that result in Base64, which is
% then stored in a database along with:
% - the username the user selected
% - the random_padding (that was used to generate the key)
% - the uuid assigned to the user (used for retrieval)
% - the nonce (mixed in with AES256)
% - the key_padding (which is the necessary bits to reach 24 of the validator)
% - the salt (the one getting mixed in with the hashing

% The password itself gets encrypted with AES256, where the generated is the
% hash from the previous step
% and an appended nonce of 12 byte.

% A mention to the libraries that are being used, all of them profiled and
% highly scruitiniced with millions of downloads

% a proof of concept, that is the client
% All the client knows is a cookie, which is a JWT, signed with RSA512