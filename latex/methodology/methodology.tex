Exploring the development and implementation of LessPM, a passwordless password
manager, our focus will be on the key components, technologies, and steps
that form the system's development process.
A crucial part of the development and system is its security and robustness.
Our approach encompasses an explanation of the system architecture, the
technologies and tools utilized and the development process to create the
prototype.
By providing a comprehensive account of the system development process, we
aim to enable readers to understand the technical aspects of our work, as well
as to assess the validity and relevance of our findings.

\subsection{Environment}\label{subsec:environment}
To implement the system, we went to approach the development from a type-safety
environment.

\subsubsection{Server}
We chose Rust as the programming language for our backend which provided
significant benefits in terms of the software development environment.

Rust's emphasis on safety and performance allowed us to create a highly
secure and efficient environment for our implementation, without the risks
typically associated with memory-related
vulnerabilities~\cite{rivera2019preserving}.
The built-in memory management and focus on concurrency ensures that our
software runs smoothly, which is crucial~\cite{fischer1985impossibility}
when dealing with sensitive user data.

Additionally, Rust's surrounding ecosystem is rapidly
growing~\cite{librs-stats}, containing a vast library of high-quality
crates\footnote{
  \texttt{Crate} is the Rust-specific name for package or library.
}, which enables rapid development and easy integration of various
functionality.
Utilizing Rust's distinctive features, the passwordless password manager provides
enhanced security and reliability in the context of user authentication,
showcasing the benefits of utilizing a modern programming language in the
ever-evolving landscape of software development.

\subsubsection{Client}
An important part of the implementation is to create a viable client that can
function as a visual entry-point to the server.
We focused on following The Law of Demeter (LoD)~\cite{lieberherr1990assuring},
and using a least-knowledge principle.
This assures that the client only retains the necessary information needed to
function, having no knowledge of the server nor its implementation between each
performed request.
As is customery when developing a system containing logging in, we are taking
advantage of JWT/JWE~\ref{subsec:json-web-tokens} to pertain some information,
in order to authorize the client between requested resources.
The Base64-encoded data that is passed between the server and client is
strongly encrypted through AES256~\ref{subsec:aes}.
The client was using React, and is a single-page application, avoiding the
possibility of utilizing any kind of URL tampering or manipulation\footnote{
  URL Manipulation is a technique performed by malefactors where a URL can be
  modified to request resources that should otherwise be inaccessbile to a user.
} to attempt privilege escalation.

\section{Key}\label{sec:key}
\subsection{Hashing AES-key}\label{subsec:hashing-aes-key}

% AUTHENTICATION
% //
% //          ┌───────────────┐     ┌───────────────┐      ┌───────────────┐
% //          │ Authenticator │     │    Browser    │      │     Site      │
% //          └───────────────┘     └───────────────┘      └───────────────┘
% //                  │                     │                      │
% //                  │                     │     1. Start Auth    │
% //                  │                     │─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─▶│
% //                  │                     │                      │
% //                  │                     │     2. Challenge     │
% //                  │                     │◀ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤
% //                  │                     │                      │
% //                  │  3. Select Token    │                      │
% //             ─ ─ ─│◀ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│                      │
% //  4. Verify │     │                     │                      │
% //                  │    4. Yield Sig     │                      │
% //            └ ─ ─▶│─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─▶                      │
% //                  │                     │    5. Send Auth      │
% //                  │                     │        Opts          │
% //                  │                     │─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─▶│─ ─ ─
% //                  │                     │                      │     │ 5. Verify
% //                  │                     │                      │          Sig
% //                  │                     │                      │◀─ ─ ┘
% //                  │                     │                      │
% //                  │                     │                      │
%
% using a web server

% Content served over HTTPS through a self-signed certificate
% Axum as a framework to serve HTTP-content
% Cors configuration
% Preflight-mention to the client
% Allow authorization and cookie
% cookie stored in HttpOnly (inaccessible to JS). And expiry time which is the same as the JWT.
% JWT - you only have one minute to login after the request is performed. RSASSA-PSS using SHA-512
% Find some information about the JWT and use as a reference to talk about the transiton to JWE
% From JWT -> JWE
% - For security purposes, there should have been a new key for EACH JWT process
% There are 15 minutes to interact and do what you want after you're signed in.
% Password is copiable from the client but does disappear after 15 seconds.
% The server acts as a one source of truth, client is ONLY rendering and doesn't store anything
% (other than the cookie)

% From PBKDF2 (SHA256) to Argon2
% Argon configuration related to my system
% Security over usability (In this case)

% A longer text about WebAuthn, part of the FIDO-2 standard, a validator key that is UNIQUE across all registrations
% - makes it more difficult to track (suseptiable to email and the likes still).
% The key is stored in the database with the user

% Explain the encryption process in detail
% From generating a 416-bit HASH; 192 from the client validator, 96 from a random padding, 128 from the pepper.

% First, we generate a "key". This key consists of:
% - 192 bits from the client validator.
%   - The validator is different in size, tested on an iPhone 13 pro max, Samsung S21, MacBook Pro 16 inch Intel i9.
%   - Since the validator is different in size, we stop at 24 byte. If the validator is shorter, we PAD.
%   - So password A has the validator + a potential, necessary padding to reach 24 byte
%   - Password B has the validator + a potential, necessary padding to reach 24 byte.
%   - The padding is unique for each password and each validator.
% - 96 bits of randomly generated padding.
% - 128 bits from a pepper.

% After the key construction, we generate a salt of 96 bit. This salt gets mixed into the Argon2 hash.
% This constructs the hash, and the hash acts as the key for AES, so it is random.

% We use this HASH as the key for AES256_GCM to encrypt the data (password) encoding that result in Base64, which is
% then stored in a database along with:
% - the username the user selected
% - the random_padding (that was used to generate the key)
% - the uuid assigned to the user (used for retrieval)
% - the nonce (mixed in with AES256)
% - the key_padding (which is the necessary bits to reach 24 of the validator)
% - the salt (the one getting mixed in with the hashing

% The password itself gets encrypted with AES256, where the generated is the hash from the previous step
% and an appended nonce of 12 byte.

% A mention to the libraries that are being used, all of them profiled and highly scruitiniced with
% millions of downloads

% a proof of concept, that is the client
% All the client knows is a cookie, which is a JWT, encrypted with RSA512