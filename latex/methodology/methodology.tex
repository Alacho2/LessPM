Exploring the development and implementation of LessPM, a passwordless password
manager, our focus will be on the key components, technologies, and steps
that form the system's development process.
A crucial part of the development and system is its security and robustness.
Our approach encompasses an explanation of the system architecture, the
technologies and tools utilized and the development process to create the
prototype.
By providing a comprehensive account of the system development process, we
aim to enable readers to understand the technical aspects of our work, as well
as to assess the validity and relevance of our findings.

\subsection{Environment}\label{subsec:environment}
To implement the system, we went to approach the development from a type-safety
environment.

\subsubsection{Server}
We chose Rust as the programming language for our backend which provided
significant benefits in terms of the software development environment.

Rust's emphasis on safety and performance allowed us to create a highly
secure and efficient environment for our implementation, without the risks
typically associated with memory-related
vulnerabilities~\cite{rivera2019preserving}.
The built-in memory management and focus on concurrency ensures that our
software runs smoothly, which is crucial~\cite{fischer1985impossibility}
when dealing with sensitive user data.

Additionally, Rust's surrounding ecosystem is rapidly
growing~\cite{librs-stats}, containing a vast library of high-quality
crates\footnote{
  \texttt{Crate} is the Rust-specific name for package or library.
}, which enables rapid development and easy integration of various
functionality.
Utilizing Rust's distinctive features, the passwordless password manager provides
enhanced security and reliability in the context of user authentication
~\cite{rivera2019preserving}, showcasing the benefits of utilizing a modern
programming language.

The backend is running an instance of an HTTPS server, serving as a wrapper
for the sensitive data.\footnote{
  During development, we took advantage of the Authorization header, as is
  specified with in RFC 7519.
  However, the framework that we used for the server requires to specifically
  expose the usage of \texttt{Authorization header} in order to access it in the
  client.
  See Section~\ref{sec:futurework} for further explanation.
}
The Chromium developers mandate this constraint to guarantee that the pertinent
API is invoked exclusively within a secure context~\cite{webdev2021credential}.
During development, the secure connection was performed through self-signed
certificate for \texttt{``localhost''} domain.

To serve as a persistent storage to maintain the passwords, user accounts,
and other related data, LessPM adopted MongoDB\@.
MongoDB allowed us to take use of their NoSQL architecture, permitting
storing Object-like structures~\cite{mongodb2021nosql}.

\subsubsection{Client}
An important part of the implementation is to create a viable client that can
function as a visual entry-point to the server.
For simplicity of the project, we chose React as a framework.
React is a JavaScript library for building user interfaces, offering a
efficient and flexible approach to web development.
We focused on following The Law of Demeter (LoD)~\cite{lieberherr1990assuring},
and using a least-knowledge principle.
This assures that the client only retains the necessary information needed to
function, having no knowledge of the server nor its implementation between each
performed request.

As is customery when developing a system containing authentication and
authorization, we are taking advantage of JWT/JWE
(Section~\ref{subsec:json-web-tokens})
to pertain some information, in order to authorize the client between
requested resources.
The Base64-encoded data that is passed between the server and client is
strongly encrypted through AES256 (Section~\ref{subsec:aes}).
We took advantage of React's ability to construct a single-page application with
no routing capabilities, avoiding the possibility of utilizing any kind of URL
tampering or manipulation\footnote{
  URL Manipulation is a technique performed by malefactors where a URL can be
  modified to request resources that should otherwise be inaccessbile to a user.
} to attempt privilege escalation.

\subsection{WebAuthn}\label{subsec:webauthn-methodology}
We used WebAuthn to perform the passwordless authentication.
As an open standard, WebAuthn aims to provide a key-based authentication
scheme in order to strongly authenticate users.
Keys are generated on a device in a user's possession and each time a
user signs up for a new service, a new key gets randomly generated on the
user's device (See Section~\ref{subsec:webauthn}).

WebAuthn is intuitively designed to attempt to mitigate phishing,
man-in-the-middle, and brute-force attacks~\cite{webauthn_level_2}.
By leveraging the increasing market of smartphones with
biometrics~\cite{statista-biometric-transactions}, WebAuthn becomes a natural
extension in terms of Authentication.

\subsubsection{Registration}
When a user tries to register in LessPM, the first thing we do is check
whether a user with a similar name exists.
We deny the registration if the user exists.
If there are no user with that name within the system, we generate a unique ID
using UUID V4, and starts the necessary Registration Ceremony.

We generate a JWE during this process, which is signed with RSASSA-PSS
using SHA-512 before getting encrypted with AES256 (See
Section~\ref{sec:futurework}).
This claim is then attached to the request's \texttt{Authorization} header,
along with the Creation options from WebAuthn (See
Section~\ref{subsec:webauthn}).
The \texttt{expiration} time for this claim is set to one minute to allow the
user some time to perform the authentication.\footnote{
  WebAuthn describes a timeout performed within the system. In our case, this
  timeout is one minute.
  However, we elected this extra approach to further secure the project, and
  JWEs need a timeout. See Section~\ref{subsec:json-web-tokens}.
}
The claim expires after this minute and the user will then have to restart the
process.
This was a decision we made to further emphasize security within LessPM\@.

When the response comes back to the user, LessPM uses the browser built-in
WebAuthn API to prompt the user for their authentication (See
Section~\ref{subsec:webauthn}).
At this point, it is entirely up to the user how they decide to perform the
authentication.
In our case, we used an Apple iPhone 13 Pro Max, a Samsung S21, and a Samsung
AX \todo[inline]{Ask Eva what kind of phone it is} to test authentication.\footnote{
  Other alternatives would include a YubiKey, NitroKey, etc.
}
We scanned the QR codes prompted through our phones, which initiates the
key-pair generation on the device after a face scan\footnote{
  There is a question of concern that facial recognistion can be bypassed
  through using a photography.
  Apple takes advantage of a built-in sensors to
  scan depth, colors, and a dot projector to create a 3D scan of a person's
  face.
  This prevents usage of a photography to perform authentication through
  their FaceID and TrueDepth technology~\cite{apple-support}.
}.
The public key then gets transmitted to the browser and sent to the Relying
Party through a new request.
Before the request reaches the Relying Party, there is an authentication
middleware, which checks for the JWE that got sent earlier and denies the
request with an \texttt{Unauthorized} status code if the request is not valid.
\footnote{
  Validity in this contex means not timed out, tampered with, or similar.
}
The user is then stored in the database if WebAuthn can validate the key and
metadata sent with teh request, and then the user gets stored in the database,
along with the UUID generated.

\subsubsection{Authentication}
Authentication is quite similar to the registration process.
The database gets checked upon an incoming request to the server.
The server immediately rejects the request if the user does not exist in the
database.

Further, the server attempts an Authentication Ceremony by collecting the
public key from database.
Upon validation\footnote{
  Validation in this context only means that the key stored in the database
  is a valid key.
} of the public key, the server creates a new JWE, which also receives an
\texttt{expiry} of one minute for the user to authenticate (See
Section~\ref{subsec:webauthn}), before sending that and the challenge in the
response.
We then prompt the user to authenticate with their original authenticator
that they used in the registration step, having the authenticator sign the
challenge before performing a new request to the server with the signed
challenge.
The user is considered authenticated if the Relying Party accepts the signed
challenge.



\todo[inline]{Make sure to mention the 15 minutes when you write this.}

\subsubsection{Password Creation \& Retrieval}

\subsection{Cors}\label{subsec:cors}
With the server and client running separately on different ports, Cross-Origin
Resource Sharing (CORS) needed to be configured correctly.

When a web page tries to access a resource hosted on another domain, browsers
perform an additional request to the server, called a \texttt{``preflight''}.
The preflight request is responsible for determining whether the actual
request that the web page is trying to make to the server is allowed.
This request is done through the \texttt{OPTIONS} method in HTTP, and contain
some information about the origin, accepted Content-Type, and similar of the
actual request.
The server response to this with what methods and headers are allowed,
denying the actual request from ever happening if the preflight is not
successful.

We constructed a CORS \texttt{layer}\footnote{
  A layer is referred to in this context as a wrapper around all other requests.
} which contained the two domains for the server and client, including
credentials\footnote{
  To pass the JWT token back and forth between the server
} and then permitting the two HTTP methods \texttt{POST} and \texttt{GET}.
We made sure the \texttt{Content-Type, Authorization}, and \texttt{Cookie}
headers are permitted.

Any other methods or headers should abort the request in the preflight.

\subsection{Cookie}\label{subsec:cookie}
JavaScript can access and manipulate \texttt{Cookies}~\cite{he2019malicious}.
We are utilizing the browser's local cookie storage to attempt secure
authentication between requests.\footnote{
  The cookie storage in a browser is subject to any vulnerabilities that can
  be performed on a SQLite database while having access to the computer where
  it is running.
}
Attempting a couple of strategies listed below, we aim to fortify the cookie
that LessPM sets in the browser, against a malefactor:
\begin{itemize}
  \item \textbf{Strict SameSite}:
  This ensures that the cookie is protected against Cross-Site Request
  Forgery (CSRF) and inaccessible to domains of other origins than the one
  where the cookie got sent from.
  \item \textbf{Expires}:
  Since the JWE is only good for 15 minutes after the user authenticated, the
  cookie gets a similar Time-to-Live (TTL) mechanism.
  \item \textbf{Secure}:
  Making sure that a cookie is only transmitted over a secure connection
  through HTTPS\@.
  This encrypts the data being sent back and forth between the client and
  the server, attempting to avoid eavesdroppers.
  \item \textbf{HttpOnly}:
  Setting HttpOnly tells the browser to make this cookie inaccessible through
  JavaScript.
  This is important to avoid session hijacking.
\end{itemize}

\subsection{Password Encryption}\label{subsec:password-encryption}
A password can be stored and hashed using a \texttt{salt} and in a typical
authentication scheme.
The user will provide their UID along with their password, this will get
collected from the database and checked with a random salt\footnote{
  Salting is the process of adding a randomly generated string consisting of
  arbitrary characters to the password before creating a hash~\cite{
    Kharod2015}.
} that was generated when the user registered.

This complicates the process compared to what is described above, since
the passwords should be a randomly generated string that is unknown to the
applicant.


\subsection{Hashing}\label{subsec:hashing}

\subsubsection{Hashing AES-key}\label{subsubsec:hashing-aes-key}


\subsection{JWT \& JWE}\label{subsec:jwt}



% Content served over HTTPS through a self-signed certificate
% Axum as a framework to serve HTTP-content
% Cors configuration X
% Preflight-mention to the client X
% Allow authorization and cookie X
% cookie stored in HttpOnly (inaccessible to JS). And expiry time which is the same as the JWT.
% JWT - you only have one minute to login after the request is performed. RSASSA-PSS using SHA-512
% Find some information about the JWT and use as a reference to talk about the transiton to JWE
% From JWT -> JWE
% - For security purposes, there should have been a new key for EACH JWT
% process (future work)
%
% There are 15 minutes to interact and do what you want after you're signed in.
% Password is copiable from the client but does disappear after 15 seconds.
% The server acts as a one source of truth, client is ONLY rendering and doesn't store anything
% (other than the cookie)

% From PBKDF2 (SHA256) to Argon2
% Argon configuration related to my system
% Security over usability (In this case)

% A longer text about WebAuthn, part of the FIDO-2 standard, a validator key that is UNIQUE across all registrations
% - makes it more difficult to track (suseptiable to email and the likes still).
% The key is stored in the database with the user

% Explain the encryption process in detail
% From generating a 416-bit HASH; 192 from the client validator, 96 from a random padding, 128 from the pepper.

% First, we generate a "key". This key consists of:
% - 192 bits from the client validator.
%   - The validator is different in size, tested on an iPhone 13 pro max, Samsung S21, MacBook Pro 16 inch Intel i9.
%   - Since the validator is different in size, we stop at 24 byte. If the validator is shorter, we PAD.
%   - So password A has the validator + a potential, necessary padding to reach 24 byte
%   - Password B has the validator + a potential, necessary padding to reach 24 byte.
%   - The padding is unique for each password and each validator.
% - 96 bits of randomly generated padding.
% - 128 bits from a pepper.

% After the key construction, we generate a salt of 96 bit. This salt gets mixed
% into the Argon2 hash.
% This constructs the hash, and the hash acts as the key for AES, so it is
% random.

% We use this HASH as the key for AES256_GCM to encrypt the data (password)
% encoding that result in Base64, which is
% then stored in a database along with:
% - the username the user selected
% - the random_padding (that was used to generate the key)
% - the uuid assigned to the user (used for retrieval)
% - the nonce (mixed in with AES256)
% - the key_padding (which is the necessary bits to reach 24 of the validator)
% - the salt (the one getting mixed in with the hashing

% The password itself gets encrypted with AES256, where the generated is the
% hash from the previous step
% and an appended nonce of 12 byte.

% A mention to the libraries that are being used, all of them profiled and
% highly scruitiniced with millions of downloads

% a proof of concept, that is the client
% All the client knows is a cookie, which is a JWT, signed with RSA512